[
["entering-and-cleaning-data-2.html", "Chapter 6 Entering and cleaning data #2 6.1 Joining datasets 6.2 Tidy data 6.3 Gathering 6.4 Working with factors 6.5 String operations and regular expressions 6.6 In-course exercise", " Chapter 6 Entering and cleaning data #2 Download a pdf of the lecture slides covering this topic. 6.1 Joining datasets So far, you have only worked with a single data source at a time. When you work on your own projects, however, you typically will need to merge together two or more datasets to create the a data frame to answer your research question. For example, for air pollution epidemiology, you will often have to join several datasets: Health outcome data (e.g., number of deaths per day) Air pollution concentrations Weather measurements (since weather can be a confounder) Demographic data The dplyr package has a family of different functions to join two dataframes together, the *_join family of functions. All combine two dataframes, which I’ll call x and y here. The functions include: inner_join(x, y): Keep only rows where there are observations in both x and y. left_join(x, y): Keep all rows from x, whether they have a match in y or not. right_join(x, y): Keep all rows from y, whether they have a match in x or not. full_join(x, y): Keep all rows from both x and y, whether they have a match in the other dataset or not. In the examples, I’ll use two datasets, x and y. Both datasets include the column course. The other column in x is grade, while the other column in y is day. Observations exist for courses x and y in both datasets, but for w and z in only one dataset. x &lt;- data.frame(course = c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;), grade = c(90, 82, 78)) y &lt;- data.frame(course = c(&quot;w&quot;, &quot;x&quot;, &quot;y&quot;), day = c(&quot;Tues&quot;, &quot;Mon / Fri&quot;, &quot;Tue&quot;)) Here is what these two example datasets look like: x ## course grade ## 1 x 90 ## 2 y 82 ## 3 z 78 y ## course day ## 1 w Tues ## 2 x Mon / Fri ## 3 y Tue With inner_join, you’ll only get the observations that show up in both datasets. That means you’ll lose data on z (only in the first dataset) and w (only in the second dataset). inner_join(x, y) ## Joining, by = &quot;course&quot; ## course grade day ## 1 x 90 Mon / Fri ## 2 y 82 Tue With left_join, you’ll keep everything in x (the “left” dataset), but not keep things in y that don’t match something in x. That means that, here, you’ll lose w: left_join(x, y) ## Joining, by = &quot;course&quot; ## course grade day ## 1 x 90 Mon / Fri ## 2 y 82 Tue ## 3 z 78 &lt;NA&gt; right_join is the opposite: right_join(x, y) ## Joining, by = &quot;course&quot; ## course grade day ## 1 w NA Tues ## 2 x 90 Mon / Fri ## 3 y 82 Tue full_join keeps everything from both datasets: full_join(x, y) ## Joining, by = &quot;course&quot; ## course grade day ## 1 x 90 Mon / Fri ## 2 y 82 Tue ## 3 z 78 &lt;NA&gt; ## 4 w NA Tues 6.2 Tidy data All of the material in this section comes directly from Hadley Wickham’s paper on tidy data. You will need to read this paper to prepare for the quiz on this section. Getting your data into a “tidy” format makes it easier to model and plot. By taking the time to tidy your data at the start of an analysis, you will save yourself time, and make it easier to plan out later steps. Characteristics of tidy data are: Each variable forms a column. Each observation forms a row. Each type of observational unit forms a table. Here are five common problems that Hadley Wickham has identified that keep data from being tidy: Column headers are values, not variable names. Multiple variables are stored in one column. Variables are stored in both rows and columns. Multiple types of observational units are stored in the same table. A single observational unit is stored in multiple tables. Here are examples (again, from Hadley Wickham’s paper on tidy data, which is required reading for this week of the course) of each of these problems. Column headers are values, not variable names. Solution: Multiple variables are stored in one column. Solution: Variables are stored in both rows and columns. Solution: Multiple types of observational units are stored in the same table. Solution: A single observational unit is stored in multiple tables. Example: exposure and outcome data stored in different files: File 1: Daily mortality counts File 2: Daily air pollution measurements 6.3 Gathering There are two functions from the tidyr package (another member of the tidyverse) that you can use to change between wide and long data: gather and spread. Here is a description of these two functions: gather: Take several columns and gather them into two columns, one with the former column names, and one with the former cell values. spread: Take two columns and spread them into multiple columns. Column names for the new columns will come from one of the two original columns, while cell values will come from the other of the original columns. The following examples are from tidyr help files and show the effects of gathering and spreading a dataset. Here is some simulated wide data: wide_stocks[1:3, ] ## time X Y Z ## 1 2009-01-01 -0.2746879 -2.5954241 3.6425013 ## 2 2009-01-02 -0.6884629 0.9647569 9.9091307 ## 3 2009-01-03 0.3924104 0.6905928 -0.3693205 In the wide_stocks dataset, there are separate columns for three different stocks (X, Y, and Z). Each cell gives the value for a certain stock on a certain day. This data isn’t “tidy”, because the identify of the stock (X, Y, or Z) is a variable, and you’ll probably want to include it as a variable in modeling. wide_stocks[1:3, ] ## time X Y Z ## 1 2009-01-01 -0.2746879 -2.5954241 3.6425013 ## 2 2009-01-02 -0.6884629 0.9647569 9.9091307 ## 3 2009-01-03 0.3924104 0.6905928 -0.3693205 If you want to convert the dataframe to have all stock values in a single column, you can use gather to convert wide data to long data: long_stocks &lt;- gather(wide_stocks, key = stock, value = price, -time) long_stocks[1:5, ] ## time stock price ## 1 2009-01-01 X -0.2746879 ## 2 2009-01-02 X -0.6884629 ## 3 2009-01-03 X 0.3924104 ## 4 2009-01-04 X -0.7445545 ## 5 2009-01-05 X 1.0958059 In this “long” dataframe, there is now one column that gives the identify of the stock (stock) and another column that gives the price of that stock that day (price): long_stocks[1:5, ] ## time stock price ## 1 2009-01-01 X -0.2746879 ## 2 2009-01-02 X -0.6884629 ## 3 2009-01-03 X 0.3924104 ## 4 2009-01-04 X -0.7445545 ## 5 2009-01-05 X 1.0958059 The format for a gather call is: ## Generic code new_df &lt;- gather(old_df, key = [name of column with old column names], value = [name of column with cell values], - [name of column(s) you want to exclude from gather]) Three important notes: Everything is gathered into one of two columns – one column with the old column names, and one column with the old cell values With the key and value arguments, you are just providing column names for the two columns that everything’s gathered into. If there is a column you don’t want to gather (date in the example), use - to exclude it in the gather call. Notice how easy it is, now that the data is gathered, to use stock for aesthetics of faceting in a ggplot2 call: ggplot(long_stocks, aes(x = time, y = price)) + geom_line() + facet_grid(. ~ stock) If you have data in a “long” format and would like to spread it out, you can use spread to do that: stocks &lt;- spread(long_stocks, key = stock, value = price) stocks[1:5, ] ## time X Y Z ## 1 2009-01-01 -0.2746879 -2.5954241 3.6425013 ## 2 2009-01-02 -0.6884629 0.9647569 9.9091307 ## 3 2009-01-03 0.3924104 0.6905928 -0.3693205 ## 4 2009-01-04 -0.7445545 -0.6228527 -2.2766329 ## 5 2009-01-05 1.0958059 1.6784257 2.2828422 Notice that this reverses the action of gather. “Spread” data is typically not tidy, so you often won’t want to use spread when you are preparing data for analysis. However, spread can be very helpful in creating clean tables for final reports and presentations. For example, if you wanted to create a table with means and standard deviations for each of the three stocks, you could use spread to rearrange the final summary to create an attractive table. stock_summary &lt;- long_stocks %&gt;% group_by(stock) %&gt;% summarize(N = n(), mean = mean(price), sd = sd(price)) stock_summary ## # A tibble: 3 x 4 ## stock N mean sd ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 X 10 0.0421 0.707 ## 2 Y 10 -0.175 1.58 ## 3 Z 10 2.25 4.16 stock_summary %&gt;% mutate(&quot;Mean (Std.dev.)&quot; = paste0(round(mean, 2), &quot; (&quot;, round(sd, 2), &quot;)&quot;)) %&gt;% select(- mean, - sd) %&gt;% gather(key = &quot;Statistic&quot;, value = &quot;Value&quot;, -stock) %&gt;% spread(key = stock, value = Value) %&gt;% knitr::kable() Statistic X Y Z Mean (Std.dev.) 0.04 (0.71) -0.17 (1.58) 2.25 (4.16) N 10 10 10 6.4 Working with factors Hadley Wickham has developed a package called forcats that helps you work with categorical variables (factors). I’ll show some examples of its functions using the worldcup dataset: library(forcats) library(faraway) data(worldcup) The fct_recode function can be used to change the labels of a function (along the lines of using factor with levels and labels to reset factor labels). One big advantage is that fct_recode lets you change labels for some, but not all, levels. For example, here are the team names: library(stringr) worldcup %&gt;% filter(str_detect(Team, &quot;^US&quot;)) %&gt;% slice(1:3) %&gt;% select(Team, Position, Time) ## # A tibble: 3 x 3 ## Team Position Time ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 USA Midfielder 10 ## 2 USA Defender 390 ## 3 USA Defender 200 If you just want to change “USA” to “United States,” you can run: worldcup &lt;- worldcup %&gt;% mutate(Team = fct_recode(Team, `United States` = &quot;USA&quot;)) worldcup %&gt;% filter(str_detect(Team, &quot;^Un&quot;)) %&gt;% slice(1:3) %&gt;% select(Team, Position, Time) ## # A tibble: 3 x 3 ## Team Position Time ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 United States Midfielder 10 ## 2 United States Defender 390 ## 3 United States Defender 200 You can use the fct_lump function to lump uncommon factors into an “Other” category. For example, to lump the two least common positions together, you can run (n specifies how many categories to keep outside of “Other”): worldcup %&gt;% dplyr::mutate(Position = forcats::fct_lump(Position, n = 2)) %&gt;% dplyr::count(Position) ## # A tibble: 3 x 2 ## Position n ## &lt;fct&gt; &lt;int&gt; ## 1 Defender 188 ## 2 Midfielder 228 ## 3 Other 179 You can use the fct_infreq function to reorder the levels of a factor from most common to least common: levels(worldcup$Position) ## [1] &quot;Defender&quot; &quot;Forward&quot; &quot;Goalkeeper&quot; &quot;Midfielder&quot; worldcup &lt;- worldcup %&gt;% mutate(Position = fct_infreq(Position)) levels(worldcup$Position) ## [1] &quot;Midfielder&quot; &quot;Defender&quot; &quot;Forward&quot; &quot;Goalkeeper&quot; If you want to reorder one factor by another variable (ascending order), you can use fct_reorder (e.g., homework 3). For example, to relevel Position by the average shots on goals for each position, you can run: levels(worldcup$Position) ## [1] &quot;Midfielder&quot; &quot;Defender&quot; &quot;Forward&quot; &quot;Goalkeeper&quot; worldcup &lt;- worldcup %&gt;% group_by(Position) %&gt;% mutate(ave_shots = mean(Shots)) %&gt;% ungroup() %&gt;% mutate(Position = fct_reorder(Position, ave_shots)) levels(worldcup$Position) ## [1] &quot;Goalkeeper&quot; &quot;Defender&quot; &quot;Midfielder&quot; &quot;Forward&quot; 6.5 String operations and regular expressions For these examples, we’ll use some data on passengers of the Titanic. You can load this data using: # install.packages(&quot;titanic&quot;) library(titanic) data(&quot;titanic_train&quot;) We will be using the stringr package: library(stringr) This data includes a column called “Name” with passenger names. This column is somewhat messy and includes several elements that we might want to separate (last name, first name, title). Here are the first few values of “Name”: titanic_train %&gt;% select(Name) %&gt;% slice(1:3) ## # A tibble: 3 x 1 ## Name ## &lt;chr&gt; ## 1 Braund, Mr. Owen Harris ## 2 Cumings, Mrs. John Bradley (Florence Briggs Thayer) ## 3 Heikkinen, Miss. Laina We’ve already done some things to manipulate strings. For example, if we wanted to separate “Name” into last name and first name (including title), we could actually do that with the separate function: titanic_train %&gt;% select(Name) %&gt;% slice(1:3) %&gt;% separate(Name, c(&quot;last_name&quot;, &quot;first_name&quot;), sep = &quot;, &quot;) ## # A tibble: 3 x 2 ## last_name first_name ## &lt;chr&gt; &lt;chr&gt; ## 1 Braund Mr. Owen Harris ## 2 Cumings Mrs. John Bradley (Florence Briggs Thayer) ## 3 Heikkinen Miss. Laina Notice that separate is looking for a regular pattern (“,”) and then doing something based on the location of that pattern in each string (splitting the string). There are a variety of functions in R that can perform manipulations based on finding regular patterns in character strings. The str_detect function will look through each element of a character vector for a designated pattern. If the pattern is there, it will return TRUE, and otherwise FALSE. The convention is: ## Generic code str_detect(string = [vector you want to check], pattern = [pattern you want to check for]) For example, to create a logical vector specifying which of the Titanic passenger names include “Mrs.”, you can call: mrs &lt;- str_detect(titanic_train$Name, &quot;Mrs.&quot;) head(mrs) ## [1] FALSE TRUE FALSE TRUE FALSE FALSE The result is a logical vector, so str_detect can be used in filter to subset data to only rows where the passenger’s name includes “Mrs.”: titanic_train %&gt;% filter(str_detect(Name, &quot;Mrs.&quot;)) %&gt;% select(Name) %&gt;% slice(1:3) ## # A tibble: 3 x 1 ## Name ## &lt;chr&gt; ## 1 Cumings, Mrs. John Bradley (Florence Briggs Thayer) ## 2 Futrelle, Mrs. Jacques Heath (Lily May Peel) ## 3 Johnson, Mrs. Oscar W (Elisabeth Vilhelmina Berg) There is an older, base R function called grepl that does something very similar (although note that the order of the arguments is reversed). titanic_train %&gt;% filter(grepl(&quot;Mrs.&quot;, Name)) %&gt;% select(Name) %&gt;% slice(1:3) ## # A tibble: 3 x 1 ## Name ## &lt;chr&gt; ## 1 Cumings, Mrs. John Bradley (Florence Briggs Thayer) ## 2 Futrelle, Mrs. Jacques Heath (Lily May Peel) ## 3 Johnson, Mrs. Oscar W (Elisabeth Vilhelmina Berg) The str_extract function can be used to extract a string (if it exists) from each value in a character vector. It follows similar conventions to str_detect: ## Generic code str_extract(string = [vector you want to check], pattern = [pattern you want to check for]) For example, you might want to extract “Mrs.” if it exists in a passenger’s name: titanic_train %&gt;% mutate(mrs = str_extract(Name, &quot;Mrs.&quot;)) %&gt;% select(Name, mrs) %&gt;% slice(1:3) ## # A tibble: 3 x 2 ## Name mrs ## &lt;chr&gt; &lt;chr&gt; ## 1 Braund, Mr. Owen Harris &lt;NA&gt; ## 2 Cumings, Mrs. John Bradley (Florence Briggs Thayer) Mrs. ## 3 Heikkinen, Miss. Laina &lt;NA&gt; Notice that now we’re creating a new column (mrs) that either has “Mrs.” (if there’s a match) or is missing (NA) if there’s not a match. For this first example, we were looking for an exact string (“Mrs”). However, you can use patterns that match a particular pattern, but not an exact string. For example, we could expand the regular expression to find “Mr.” or “Mrs.”: titanic_train %&gt;% mutate(title = str_extract(Name, &quot;Mr\\\\.|Mrs\\\\.&quot;)) %&gt;% select(Name, title) %&gt;% slice(1:3) ## # A tibble: 3 x 2 ## Name title ## &lt;chr&gt; &lt;chr&gt; ## 1 Braund, Mr. Owen Harris Mr. ## 2 Cumings, Mrs. John Bradley (Florence Briggs Thayer) Mrs. ## 3 Heikkinen, Miss. Laina &lt;NA&gt; Note that this pattern uses a special operator (|) to find one pattern or another. Double backslashes (\\\\) escape the special character “.”. As a note, in regular expressions, all of the following characters are special characters that need to be escaped with backslashes if you want to use them literally: . * + ^ ? $ \\ | ( ) [ ] { } Notice that “Mr.” and “Mrs.” both start with “Mr”, end with “.”, and may or may not have an “s” in between. titanic_train %&gt;% mutate(title = str_extract(Name, &quot;Mr(s)*\\\\.&quot;)) %&gt;% select(Name, title) %&gt;% slice(1:3) ## # A tibble: 3 x 2 ## Name title ## &lt;chr&gt; &lt;chr&gt; ## 1 Braund, Mr. Owen Harris Mr. ## 2 Cumings, Mrs. John Bradley (Florence Briggs Thayer) Mrs. ## 3 Heikkinen, Miss. Laina &lt;NA&gt; This pattern uses (s)* to match zero or more “s”s at this spot in the pattern. In the previous code, we found “Mr.” and “Mrs.”, but missed “Miss.”. We could tweak the pattern again to try to capture that, as well. For all three, we have the pattern that it starts with “M”, has some lowercase letters, and then ends with “.”. titanic_train %&gt;% mutate(title = str_extract(Name, &quot;M[a-z]+\\\\.&quot;)) %&gt;% select(Name, title) %&gt;% slice(1:3) ## # A tibble: 3 x 2 ## Name title ## &lt;chr&gt; &lt;chr&gt; ## 1 Braund, Mr. Owen Harris Mr. ## 2 Cumings, Mrs. John Bradley (Florence Briggs Thayer) Mrs. ## 3 Heikkinen, Miss. Laina Miss. The last pattern used [a-z]+ to match one or more lowercase letters. The [a-z]is a character class. You can also match digits ([0-9]), uppercase letters ([A-Z]), just some letters ([aeiou]), etc. You can negate a character class by starting it with ^. For example, [^0-9] will match anything that isn’t a digit. Sometimes, you want to match a pattern, but then only subset a part of it. For example, each passenger seems to have a title (“Mr.”, “Mrs.”, etc.) that comes after “,” and before “.”. We can use this pattern to find the title, but then we get some extra stuff with the match: titanic_train %&gt;% mutate(title = str_extract(Name, &quot;,\\\\s[A-Za-z]*\\\\.\\\\s&quot;)) %&gt;% select(title) %&gt;% slice(1:3) ## # A tibble: 3 x 1 ## title ## &lt;chr&gt; ## 1 &quot;, Mr. &quot; ## 2 &quot;, Mrs. &quot; ## 3 &quot;, Miss. &quot; As a note, in this pattern, \\\\s is used to match a space. We are getting things like “, Mr.”, when we really want “Mr”. We can use the str_match function to do this. We group what we want to extract from the pattern in parentheses, and then the function returns a matrix. The first column is the full pattern match, and each following column gives just what matches within the groups. head(str_match(titanic_train$Name, pattern = &quot;,\\\\s([A-Za-z]*)\\\\.\\\\s&quot;)) ## [,1] [,2] ## [1,] &quot;, Mr. &quot; &quot;Mr&quot; ## [2,] &quot;, Mrs. &quot; &quot;Mrs&quot; ## [3,] &quot;, Miss. &quot; &quot;Miss&quot; ## [4,] &quot;, Mrs. &quot; &quot;Mrs&quot; ## [5,] &quot;, Mr. &quot; &quot;Mr&quot; ## [6,] &quot;, Mr. &quot; &quot;Mr&quot; To get just the title, then, we can run: titanic_train %&gt;% mutate(title = str_match(Name, &quot;,\\\\s([A-Za-z]*)\\\\.\\\\s&quot;)[ , 2]) %&gt;% select(Name, title) %&gt;% slice(1:3) ## # A tibble: 3 x 2 ## Name title ## &lt;chr&gt; &lt;chr&gt; ## 1 Braund, Mr. Owen Harris Mr ## 2 Cumings, Mrs. John Bradley (Florence Briggs Thayer) Mrs ## 3 Heikkinen, Miss. Laina Miss The [ , 2] pulls out just the second column from the matrix returned by str_match. Here are some of the most common titles: titanic_train %&gt;% mutate(title = str_match(Name, &quot;,\\\\s([A-Za-z]*)\\\\.\\\\s&quot;)[ , 2]) %&gt;% group_by(title) %&gt;% summarize(n = n()) %&gt;% arrange(desc(n)) %&gt;% slice(1:5) ## # A tibble: 5 x 2 ## title n ## &lt;chr&gt; &lt;int&gt; ## 1 Mr 517 ## 2 Miss 182 ## 3 Mrs 125 ## 4 Master 40 ## 5 Dr 7 Here are a few other examples of regular expressions in action with this dataset. Get just names that start with (“^”) the letter “A”: titanic_train %&gt;% filter(str_detect(Name, &quot;^A&quot;)) %&gt;% select(Name) %&gt;% slice(1:3) ## # A tibble: 3 x 1 ## Name ## &lt;chr&gt; ## 1 Allen, Mr. William Henry ## 2 Andersson, Mr. Anders Johan ## 3 Asplund, Mrs. Carl Oscar (Selma Augusta Emilia Johansson) Get names with “II” or “III” ({2,} says to match at least two times): titanic_train %&gt;% filter(str_detect(Name, &quot;I{2,}&quot;)) %&gt;% select(Name) %&gt;% slice(1:3) ## # A tibble: 2 x 1 ## Name ## &lt;chr&gt; ## 1 Carter, Master. William Thornton II ## 2 Roebling, Mr. Washington Augustus II Get names with “Andersen” or “Anderson” (alternatives in square brackets): titanic_train %&gt;% filter(str_detect(Name, &quot;Anders[eo]n&quot;)) %&gt;% select(Name) ## Name ## 1 Andersen-Jensen, Miss. Carla Christine Nielsine ## 2 Anderson, Mr. Harry ## 3 Walker, Mr. William Anderson ## 4 Olsvigen, Mr. Thor Anderson ## 5 Soholt, Mr. Peter Andreas Lauritz Andersen Get names that start with (“^” outside of brackets) the letters “A” and “B”: titanic_train %&gt;% filter(str_detect(Name, &quot;^[AB]&quot;)) %&gt;% select(Name) %&gt;% slice(1:3) ## # A tibble: 3 x 1 ## Name ## &lt;chr&gt; ## 1 Braund, Mr. Owen Harris ## 2 Allen, Mr. William Henry ## 3 Bonnell, Miss. Elizabeth Get names that end with (“$”) the letter “b” (either lowercase or uppercase): titanic_train %&gt;% filter(str_detect(Name, &quot;[bB]$&quot;)) %&gt;% select(Name) ## Name ## 1 Emir, Mr. Farred Chehab ## 2 Goldschmidt, Mr. George B ## 3 Cook, Mr. Jacob ## 4 Pasic, Mr. Jakob Some useful regular expression operators include: Operator Meaning . Any character * Match 0 or more times (greedy) *? Match 0 or more times (non-greedy) + Match 1 or more times (greedy) +? Match 1 or more times (non-greedy) ^ Starts with (in brackets, negates) $ Ends with […] Character classes For more on these patterns, see: Help file for the stringi-search-regex function in the stringi package (which should install when you install stringr) Chapter 14 of R For Data Science http://gskinner.com/RegExr: Interactive tool for helping you build regular expression pattern strings 6.6 In-course exercise For today’s exercise, we’ll be using the following three datasets (click on the file name to access the correct file for today’s class for each dataset): File name Description country_timeseries.csv Ebola cases by country for the 2014 outbreak mexico_exposure.csv and mexico_deaths.csv Daily death counts and environmental measurements for Mexico City, Mexico, for 2008 measles_data/ Number of cases of measles in CA since end of Dec. 2014 Note that you likely have already downloaded all the files in the measles_data folder, since we used them in an earlier in-course exercise. If so, there is no need to re-download those files. Here are the sources for this data: country_timeseries.csv : Caitlin Rivers’ Ebola repository (Caitlin originally collected this data from the WHO and WHO Situation reports) mexico_exposure.csv and mexico_deaths.csv : one of Hadley Wickham’s GitHub repos (Hadley got the data originally from the Secretaria de Salud of Mexico’s website, although it appears the link is now broken. I separated the data into two dataframes so students could practice merging.) measles_data/: one of scarpino’s GitHub repos (Data originally from pdfs from the California Department of Public Health) If you want to use these data further, you should go back and pull them from their original sources. They are here only for use in R code examples for this course. Here are some of the packages you will need for this exercise: library(dplyr) library(gridExtra) library(ggthemes) 6.6.1 Designing tidy data Check out the country_timeseries.csv file on Ebola for this week’s example data. Talk with your partner and decide what changes you would need to make to this dataset to turn it into a “tidy” dataset, in particular which of the five common “untidy” problems the data currently has and why. Do the same for the data on daily mortality and daily weather in Mexico. Do the same for the set of files with measles data. 6.6.2 Easier data wrangling Use read_csv to read the Mexico data (exposure and mortality) directly from GitHub into your R session. Call the dataframes mex_deaths and mex_exp. Are there any values of the day column in mex_deaths that is not present in the day column of mex_exp? How about vice-versa? (Hint: There are a few ways you could check this. One is to try filtering down to just rows in one dataframe where the day values are not present in the day values from the other dataframe. The %in% logical vector may be useful.) Merge the two datasets together to create the dataframe mexico. Exclude all columns except the outcome (deaths), day, and mean temperature. Convert the day to a Date class. If you did not already, try combining all the steps in the previous task into one “chained” pipeline of code using the pipe operator, %&gt;%. Use this new dataframe to plot deaths by date in Mexico using ggplot2. The final plot should look like this: 6.6.2.1 Example R code Use read_csv to read the mexico data (exposure and mortality) directly from GitHub into your R session. Call the dataframes mex_deaths and mex_exp: deaths_url &lt;- paste0(&quot;https://github.com/geanders/RProgrammingForResearch/&quot;, &quot;raw/master/data/mexico_deaths.csv&quot;) mex_deaths &lt;- read_csv(deaths_url) head(mex_deaths) ## # A tibble: 6 x 2 ## day deaths ## &lt;chr&gt; &lt;int&gt; ## 1 1/1/08 296 ## 2 1/2/08 274 ## 3 1/3/08 339 ## 4 1/4/08 300 ## 5 1/5/08 327 ## 6 1/6/08 332 exposure_url &lt;- paste0(&quot;https://github.com/geanders/RProgrammingForResearch/&quot;, &quot;raw/master/data/mexico_exposure.csv&quot;) mex_exp &lt;- read_csv(exposure_url) head(mex_exp) ## # A tibble: 6 x 14 ## day temp_min temp_max temp_mean humidity wind NO NO2 NOX ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1/1/08 7.80 17.8 11.8 53.5 2.66 0.00925 0.0187 0.0278 ## 2 1/2/08 2.60 9.80 6.64 61.7 3.35 0.00542 0.0187 0.0241 ## 3 1/3/08 1.10 15.6 7.04 59.9 1.89 0.0160 0.0381 0.0540 ## 4 1/4/08 3.10 20.6 10.9 57.5 1.20 0.0408 0.0584 0.0993 ## 5 1/5/08 6.00 21.3 13.4 45.7 0.988 0.0469 0.0602 0.107 ## 6 1/6/08 7.20 22.1 14.3 40.8 0.854 0.0286 0.0510 0.0795 ## # ... with 5 more variables: O3 &lt;dbl&gt;, CO &lt;dbl&gt;, SO2 &lt;dbl&gt;, PM10 &lt;dbl&gt;, ## # PM25 &lt;dbl&gt; Check if there are any values of the day column in mex_deaths that are not present in the day column of mex_exp and vice-versa. mex_deaths %&gt;% filter(!(day %in% mex_exp$day)) ## # A tibble: 0 x 2 ## # ... with 2 variables: day &lt;chr&gt;, deaths &lt;int&gt; mex_exp %&gt;% filter(!(day %in% mex_deaths$day)) ## # A tibble: 0 x 14 ## # ... with 14 variables: day &lt;chr&gt;, temp_min &lt;dbl&gt;, temp_max &lt;dbl&gt;, ## # temp_mean &lt;dbl&gt;, humidity &lt;dbl&gt;, wind &lt;dbl&gt;, NO &lt;dbl&gt;, NO2 &lt;dbl&gt;, ## # NOX &lt;dbl&gt;, O3 &lt;dbl&gt;, CO &lt;dbl&gt;, SO2 &lt;dbl&gt;, PM10 &lt;dbl&gt;, PM25 &lt;dbl&gt; One important note is that, when you’re doing this check, you do not want to overwrite your original dataframe, so be sure that you do not reassign this output to mex_deaths or mex_exp. An even quicker way to do check this is to create a logical vector that checks this and use sum to add up the values in the logical vector. If the sum is zero, that tells you that the logical check is never true, so there are no cases where there is a day value in one dataframe that is not also in the other dataframe. sum(!(mex_deaths$day %in% mex_exp$day)) ## [1] 0 sum(!(mex_exp$day %in% mex_deaths$day)) ## [1] 0 Merge the two datasets together to create the dataframe mexico. Exclude all columns except the outcome (deaths), date, and mean temperature. mexico &lt;- full_join(mex_deaths, mex_exp, by = &quot;day&quot;) mexico &lt;- select(mexico, day, deaths, temp_mean) Convert the date to a date class. library(lubridate) ## For parsing dates mexico &lt;- mutate(mexico, day = mdy(day)) Try combining all the steps in the previous task into one “chained” command: mexico &lt;- full_join(mex_deaths, mex_exp, by = &quot;day&quot;) %&gt;% select(day, deaths, temp_mean) %&gt;% mutate(day = mdy(day)) head(mexico) ## # A tibble: 6 x 3 ## day deaths temp_mean ## &lt;date&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2008-01-01 296 11.8 ## 2 2008-01-02 274 6.64 ## 3 2008-01-03 339 7.04 ## 4 2008-01-04 300 10.9 ## 5 2008-01-05 327 13.4 ## 6 2008-01-06 332 14.3 Note that, in this case, all the values of day in mex_deaths have one and only one matching value in mex_exp, and vice-versa. Because of this, we would have gotten the same mexico dataframe if we’d used inner_join, left_join or right_join instead of full_join. The differences between these *_join functions come into play when you have some values of your matching column that aren’t in both of the dataframes you’re joining. Use this new dataframe to plot deaths by date using ggplot: ggplot(data = mexico) + geom_point(mapping = aes(x = day, y = deaths), size = 1.5, alpha = 0.5) + labs(x = &quot;Date in 2008&quot;, y = &quot;# of deaths&quot;) + ggtitle(&quot;Deaths by date&quot;) + theme_few() 6.6.3 More extensive data wrangling Read the Ebola data directly from GitHub into your R session. Call the dataframe ebola. Use dplyr functions to create a tidy dataset. First, change it from “wide” data to “long” data. Name the new column with the key variable and the new column with the values count. The first few lines of the “long” version of the dataset should look like this: ## # A tibble: 6 x 4 ## Date Day variable count ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 1/5/2015 289 Cases_Guinea 2776 ## 2 1/4/2015 288 Cases_Guinea 2775 ## 3 1/3/2015 287 Cases_Guinea 2769 ## 4 1/2/2015 286 Cases_Guinea NA ## 5 12/31/2014 284 Cases_Guinea 2730 ## 6 12/28/2014 281 Cases_Guinea 2706 Convert the Date column to a Date class. Use the separate function to separate the variable column into two columns, type (“Cases” or “Deaths”) and country (“Guinea”, “Liberia”, etc.). At this point, the data should look like this: ## # A tibble: 6 x 5 ## Date Day type country count ## &lt;date&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 2015-01-05 289 Cases Guinea 2776 ## 2 2015-01-04 288 Cases Guinea 2775 ## 3 2015-01-03 287 Cases Guinea 2769 ## 4 2015-01-02 286 Cases Guinea NA ## 5 2014-12-31 284 Cases Guinea 2730 ## 6 2014-12-28 281 Cases Guinea 2706 Use the spread function to convert the data so you have separate columns for the two variables of numbers of Cases and Deaths. At this point, the dataframe should look like this: ## # A tibble: 6 x 5 ## Date Day country Cases Deaths ## &lt;date&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 2014-03-22 0 Guinea 49 29 ## 2 2014-03-22 0 Liberia NA NA ## 3 2014-03-22 0 Mali NA NA ## 4 2014-03-22 0 Nigeria NA NA ## 5 2014-03-22 0 Senegal NA NA ## 6 2014-03-22 0 SierraLeone NA NA Remove any observations where counts of both cases and deaths are missing for that country on that date. Now that your data is tidy, create one plot showing Ebola cases by date, faceted by country, and one showing Ebola deaths by date, also faceted by country. Try using the option scales = &quot;free_y&quot; in the facet_wrap function and see how that changes these graphs. Discuss with your group the advantages and disadvantages of using this option when creating these small multiple plots. The plots should look something like this (if you’re using the scales = &quot;free_y&quot; option): Based on these plots, what would your next questions be about this data before you used it for an analysis? Can you put all of the steps of this cleaning process into just a few “chained” code pipelines using %&gt;%? If you have extra time (super-challenge!): There is a function called fct_reorder in the forcats package that can be used to reorder the levels of a factor in a dataframe based on another column in the same dataframe. This function can be very useful for using a meaningful order when plotting. We’ll cover the forcats package in a later class, but today check out the help file for fct_reorder and see if you can figure out how to use it to reorder the small multiple plots in order of the maximum number of cases or deaths (for the two plots respectively) in each country. You’ll be able to do this by changing the code in facet_wrap from ~ country to ~ fct_reorder(country, ...), but with the ... replaced with certain arguments. If you’re getting stuck, try running the examples in the fct_reorder helpfile to get a feel for how this function can be used when plotting. The plots will look something like this: 6.6.3.1 Example R code Read the data in using read_csv. ebola_url &lt;- paste0(&quot;https://github.com/geanders/RProgrammingForResearch/&quot;, &quot;raw/master/data/country_timeseries.csv&quot;) ebola &lt;- read_csv(ebola_url) head(ebola) ## # A tibble: 6 x 18 ## Date Day Cases_Guinea Cases_Liberia Cases_SierraLeo… Cases_Nigeria ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1/5/2015 289 2776 NA 10030 NA ## 2 1/4/2015 288 2775 NA 9780 NA ## 3 1/3/2015 287 2769 8166 9722 NA ## 4 1/2/2015 286 NA 8157 NA NA ## 5 12/31/2… 284 2730 8115 9633 NA ## 6 12/28/2… 281 2706 8018 9446 NA ## # ... with 12 more variables: Cases_Senegal &lt;int&gt;, ## # Cases_UnitedStates &lt;int&gt;, Cases_Spain &lt;int&gt;, Cases_Mali &lt;int&gt;, ## # Deaths_Guinea &lt;int&gt;, Deaths_Liberia &lt;int&gt;, Deaths_SierraLeone &lt;int&gt;, ## # Deaths_Nigeria &lt;int&gt;, Deaths_Senegal &lt;int&gt;, Deaths_UnitedStates &lt;int&gt;, ## # Deaths_Spain &lt;int&gt;, Deaths_Mali &lt;int&gt; Change the data to long data using the gather() function from dplyr: ebola &lt;- ebola %&gt;% gather(key = variable, value = count, -Date, -Day) head(ebola) ## # A tibble: 6 x 4 ## Date Day variable count ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 1/5/2015 289 Cases_Guinea 2776 ## 2 1/4/2015 288 Cases_Guinea 2775 ## 3 1/3/2015 287 Cases_Guinea 2769 ## 4 1/2/2015 286 Cases_Guinea NA ## 5 12/31/2014 284 Cases_Guinea 2730 ## 6 12/28/2014 281 Cases_Guinea 2706 Convert Date to a date class: ebola &lt;- ebola %&gt;% mutate(Date = mdy(Date)) head(ebola) ## # A tibble: 6 x 4 ## Date Day variable count ## &lt;date&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 2015-01-05 289 Cases_Guinea 2776 ## 2 2015-01-04 288 Cases_Guinea 2775 ## 3 2015-01-03 287 Cases_Guinea 2769 ## 4 2015-01-02 286 Cases_Guinea NA ## 5 2014-12-31 284 Cases_Guinea 2730 ## 6 2014-12-28 281 Cases_Guinea 2706 Split variable into type and country: ebola &lt;- ebola %&gt;% separate(variable, c(&quot;type&quot;, &quot;country&quot;), sep = &quot;_&quot;) head(ebola) ## # A tibble: 6 x 5 ## Date Day type country count ## &lt;date&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 2015-01-05 289 Cases Guinea 2776 ## 2 2015-01-04 288 Cases Guinea 2775 ## 3 2015-01-03 287 Cases Guinea 2769 ## 4 2015-01-02 286 Cases Guinea NA ## 5 2014-12-31 284 Cases Guinea 2730 ## 6 2014-12-28 281 Cases Guinea 2706 Convert the data so you have separate columns for the two variables of numbers of Cases and Deaths: ebola &lt;- spread(ebola, key = type, value = count) head(ebola) ## # A tibble: 6 x 5 ## Date Day country Cases Deaths ## &lt;date&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 2014-03-22 0 Guinea 49 29 ## 2 2014-03-22 0 Liberia NA NA ## 3 2014-03-22 0 Mali NA NA ## 4 2014-03-22 0 Nigeria NA NA ## 5 2014-03-22 0 Senegal NA NA ## 6 2014-03-22 0 SierraLeone NA NA Remove any observations where counts of cases or deaths are missing for that country: ebola &lt;- filter(ebola, !is.na(Cases) &amp; !is.na(Deaths)) head(ebola) ## # A tibble: 6 x 5 ## Date Day country Cases Deaths ## &lt;date&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 2014-03-22 0 Guinea 49 29 ## 2 2014-03-24 2 Guinea 86 59 ## 3 2014-03-25 3 Guinea 86 60 ## 4 2014-03-26 4 Guinea 86 62 ## 5 2014-03-27 5 Guinea 103 66 ## 6 2014-03-27 5 Liberia 8 6 Now that your data is tidy, create one plot showing ebola cases by date, faceted by country, and one showing ebola deaths by date, also faceted by country: ggplot(ebola, aes(x = Date, y = Cases)) + geom_line() + facet_wrap(~ country, ncol = 4) + theme_classic() ggplot(ebola, aes(x = Date, y = Deaths)) + geom_line() + facet_wrap(~ country, ncol = 4) + theme_classic() Try using the option scales = &quot;free_y&quot; in the facet_wrap() function (in the gridExtra package) and see how that changes these graphs: ggplot(ebola, aes(x = Date, y = Cases)) + geom_line() + facet_wrap(~ country, ncol = 4, scales = &quot;free_y&quot;) + theme_classic() ggplot(ebola, aes(x = Date, y = Deaths)) + geom_line() + facet_wrap(~ country, ncol = 4, scales = &quot;free_y&quot;) + theme_classic() Put all of the steps of this cleaning process into just a few “chaining” calls. ebola &lt;- read_csv(ebola_url) %&gt;% gather(variable, count, -Date, -Day) %&gt;% mutate(Date = mdy(Date)) %&gt;% separate(variable, c(&quot;type&quot;, &quot;country&quot;), sep = &quot;_&quot;) %&gt;% spread(type, count) %&gt;% filter(!is.na(Cases) &amp; !is.na(Deaths)) ggplot(ebola, aes(x = Date, y = Cases)) + geom_line() + facet_wrap(~ country, ncol = 4) + theme_classic() ggplot(ebola, aes(x = Date, y = Deaths)) + geom_line() + facet_wrap(~ country, ncol = 4) + theme_classic() Use the fct_reorder function inside the facet_wrap function call to reorder the small-multiple graphs. library(forcats) ggplot(ebola, aes(x = Date, y = Cases)) + geom_line() + facet_wrap(~ fct_reorder(country, Cases, fun = max, .desc = TRUE), ncol = 4) + theme_classic() ggplot(ebola, aes(x = Date, y = Deaths)) + geom_line() + facet_wrap(~ fct_reorder(country, Deaths, fun = max, .desc = TRUE), ncol = 4) + theme_classic() 6.6.4 Tidying VADeaths data R comes with a dataset called VADeaths that gives death rates per 1,000 people in Virginia in 1940 by age, sex, and rural / urban. Use data(&quot;VADeaths&quot;) to load this data. Make sure you understand what each column and row is showing – use the helpfile (?VADeaths) if you need. Go through the three characteristics of tidy data and the five common problems in untidy data that we talked about in class. Sketch out (you’re welcome to use the whiteboards) what a tidy version of this data would look like. Open a new R script file. Write R code to transform this dataset into a tidy dataset. Try using a pipe chain, with %&gt;% and tidyverse functions, to clean the data. Use the tidy data to create the following graph: There is no example R code for this – try to figure out the code yourselves. We will go over a solution in class. You may find the RStudio Data Wrangling cheatsheet helpful for remembering which tidyverse functions do what. 6.6.5 Exploring Fatality Analysis Reporting System (FARS) data Explore the interactive visualization at http://metrocosm.com/10-years-of-traffic-accidents-mapped.html. This was created by Max Galka using this dataset. Go to FARS web page. We want to get the raw data on fatal accidents. Navigate this page to figure out how you can get this raw data for the whole county for 2016 (hint: you’ll need to access the raw data using FTP, and you may have more success with some web browsers, like Chrome, than others). Save 2016 “National” data (csv format) to your computer. What is the structure of how this data is saved (e.g., directory structure, file structure)? On the FARS web page, find the documentation describing this raw data. Look through both this documentation (2016 Crash Report Sampling System (CRSS):Analytical User’s Manual) and the raw files you downloaded to figure out what information is included in the data. Read the accident.csv file for 2016 into R (this is one of the files you’ll get if you download the raw data for 2016). Use the documentation to figure out what each column represents. Discuss what steps you would need to take to create the following plot. To start, don’t write any code, just develop a plan. Talk about what the dataset should look like right before you create the plot and what functions you could use to get the data from its current format to that format. (Hint: Functions from the lubridate package will be very helpful, including yday and wday). Discuss which of the variables in this dataset could be used to merge the dataset with other appropriate data, either other datasets in the FARS raw data, or outside datasets. Try to write the code to create this plot. This will include some code for cleaning the data and some code for plotting. I will add one example answer after class, but I’d like you to try to figure it out yourselves first. 6.6.6 Baby names In the Fall 2018 session, we seem to have an unusually high percent of the class with names that start with an “A” or “K”. In this part of the exercise, we’ll see if we can figure out whether the proportion of “A” and “K” names is unusual. There is a package on CRAN called babynames with data on baby names by year in the United States, based on data from the U.S.’s Social Security Administration. We will use this data to compare the proportion of “A” and “K” names in our class with the proportion in these baby names. We’ll also do a few other things to explore this data. First, check out patterns in your own name. Is your name included in this dataset? Has your name been used for males and females? How have the patterns in the proportion of babies with your name, for both males and females, changed over time (use a plot to look at this)? In the year you were born, what were the 5 most popular baby names for males and females? Try to come up with some attractive ways (figures and tables) to show this. 6.6.6.1 Example R code Install and load the babynames package and its “babynames” dataframe: # install.packages(&quot;babynames&quot;) library(babynames) data(&quot;babynames&quot;) Remember that you can use ?babynames to find out more about this dataframe. Check out patterns in your own name. Is your name included in this dataset? You can use filter to create a subset of this data where you’ve filtered down to just the rows with your name. To see if your name ever shows up, you can use count on this dataframe—if your name never shows up, then you will have 0 rows in the new dataframe. As long as there’s at least one row, your name shows up somewhere. (If your name is not in here, try your middle or last name, or the name of a fictional character you like, for the rest of these exercises.) my_name &lt;- babynames %&gt;% filter(name == &quot;Brooke&quot;) my_name %&gt;% count() ## # A tibble: 1 x 1 ## nn ## &lt;int&gt; ## 1 171 Has your name been used for males and females? To figure this out, you can group the dataset with rows with your name by the sex column and then use count to count the number of rows in the dataset for males and females. If your name has only been used for one gender, then only one row will result from running this code (for an example, try my first name, “Georgiana”). my_name %&gt;% group_by(sex) %&gt;% count() ## # A tibble: 2 x 2 ## # Groups: sex [2] ## sex nn ## &lt;chr&gt; &lt;int&gt; ## 1 F 80 ## 2 M 91 How have the patterns in the proportion of babies with your name, for both males and females, changed over time (use a plot to look at this)? To check this out, I recommend you create a plot of the proportion of babies with your name (prop) versus year (year). You can use color to show these patterns for males and females separately. I’ve done some extra things here to (1) relabel the sex factor, so the label shows up with clearer names and (2) change the labels for the x-, y-, and color scales. library(forcats) my_name %&gt;% mutate(sex = fct_recode(sex, Male = &quot;M&quot;, Female = &quot;F&quot;)) %&gt;% ggplot(aes(x = year, y = prop, color = sex)) + geom_line() + labs(x = &quot;Year&quot;, y = &quot;Proportion of babies\\nof each sex named &#39;Brooke&#39;&quot;, color = &quot;&quot;) In the year you were born, what were the 5 most popular baby names for males and females? top_my_year &lt;- babynames %&gt;% filter(year == 1981) %&gt;% group_by(sex) %&gt;% arrange(desc(prop)) %&gt;% slice(1:5) top_my_year ## # A tibble: 10 x 5 ## # Groups: sex [2] ## year sex name n prop ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1981. F Jennifer 57043 0.0319 ## 2 1981. F Jessica 42527 0.0238 ## 3 1981. F Amanda 34373 0.0192 ## 4 1981. F Sarah 28171 0.0158 ## 5 1981. F Melissa 28007 0.0157 ## 6 1981. M Michael 68765 0.0369 ## 7 1981. M Christopher 50224 0.0270 ## 8 1981. M Matthew 43326 0.0233 ## 9 1981. M Jason 41928 0.0225 ## 10 1981. M David 40646 0.0218 If you’d like to show this in a prettier way, you could show this as a table: library(knitr) top_my_year %&gt;% mutate(rank = 1:n()) %&gt;% # Since the data is grouped by sex, this will rank # separately for females and males ungroup() %&gt;% # You have to ungroup before you can run `mutate` on `sex` mutate(sex = fct_recode(sex, Male = &quot;M&quot;, Female = &quot;F&quot;), percent = round(100 * prop, 1), percent = paste(percent, &quot;%&quot;, sep = &quot;&quot;)) %&gt;% select(sex, rank, name, percent) %&gt;% kable() sex rank name percent Female 1 Jennifer 3.2% Female 2 Jessica 2.4% Female 3 Amanda 1.9% Female 4 Sarah 1.6% Female 5 Melissa 1.6% Male 1 Michael 3.7% Male 2 Christopher 2.7% Male 3 Matthew 2.3% Male 4 Jason 2.3% Male 5 David 2.2% You could also show it as a figure: library(scales) top_my_year %&gt;% ungroup() %&gt;% mutate(name = fct_reorder(name, prop, desc = TRUE), sex = fct_recode(sex, Male = &quot;M&quot;, Female = &quot;F&quot;)) %&gt;% ggplot(aes(x = name)) + geom_bar(aes(weight = prop)) + coord_flip() + labs(x = &quot;&quot;, y = &quot;Percent of babies with name in 1981&quot;) + theme(legend.position = &quot;top&quot;) + scale_y_continuous(labels = percent) + facet_wrap(~ sex, scales = &quot;free_y&quot;) + theme_classic() 6.6.7 More with baby names Now let’s look at baby names based on the letter they start with. For the full dataframe, what proportion of baby names start with each letter? See if you can create a figure to help show this. Create the same plot using the names of people from our class. What proportion of names start with “A” or “K” across the full dataset? How about for the years from 1980 to 1995? Finally, how does the proportion change over the years in the dataframe? 6.6.7.1 Example R code For the full dataframe, what proportion of baby names start with “A” or “K”? To start, create a column with the first letter of each name. You can use functions in the stringr package to do this. The easiest might be to use the position of the first letter to pull that information. library(stringr) top_letters &lt;- babynames %&gt;% mutate(first_letter = str_sub(name, 1, 1)) top_letters %&gt;% select(name, first_letter) %&gt;% slice(1:5) ## # A tibble: 5 x 2 ## name first_letter ## &lt;chr&gt; &lt;chr&gt; ## 1 Mary M ## 2 Anna A ## 3 Emma E ## 4 Elizabeth E ## 5 Minnie M Now we can group by letter and figure out these proportions. First, while the data is grouped, count the number of names with each letter. Then, ungroup and use mutate to divide this by the total number of names: top_letters &lt;- top_letters %&gt;% group_by(first_letter) %&gt;% summarize(n = sum(n)) %&gt;% ungroup() %&gt;% mutate(prop = n / sum(n)) %&gt;% arrange(desc(prop)) top_letters ## # A tibble: 26 x 3 ## first_letter n prop ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 J 43937781 0.129 ## 2 M 32272079 0.0947 ## 3 A 27836232 0.0817 ## 4 C 25039495 0.0735 ## 5 D 23953374 0.0703 ## 6 R 23388453 0.0686 ## 7 S 20967535 0.0615 ## 8 L 18449395 0.0541 ## 9 K 16608111 0.0487 ## 10 E 16504812 0.0484 ## # ... with 16 more rows Here’s one way to visualize this: top_letters %&gt;% mutate(first_letter = fct_reorder(first_letter, prop)) %&gt;% ggplot(aes(x = first_letter)) + geom_bar(aes(weight = prop)) + coord_flip() + scale_y_continuous(labels = percent) + labs(x = &quot;&quot;, y = &quot;Percent of names that start with ...&quot;) Create the same plot using the names of people in our class. First, create a vector with the names of people in our class: student_list &lt;- data_frame(name = c(&quot;Aeriel&quot;, &quot;Rebecca&quot;, &quot;Grant&quot;, &quot;Amy&quot;, &quot;Jessy&quot;, &quot;Alyssa&quot;, &quot;Camron&quot;, &quot;Anastasia&quot;, &quot;Kyle&quot;, &quot;Ana&quot;, &quot;Amanda&quot;, &quot;Kathleen&quot;, &quot;Kyle&quot;, &quot;Ana&quot;, &quot;Amanda&quot;, &quot;Kathleen&quot;, &quot;Kayla&quot;, &quot;Nichole&quot;, &quot;Randy&quot;, &quot;Katy&quot;, &quot;Devin&quot;)) student_list &lt;- student_list %&gt;% mutate(first_letter = str_sub(name, 1, 1)) student_list ## # A tibble: 21 x 2 ## name first_letter ## &lt;chr&gt; &lt;chr&gt; ## 1 Aeriel A ## 2 Rebecca R ## 3 Grant G ## 4 Amy A ## 5 Jessy J ## 6 Alyssa A ## 7 Camron C ## 8 Anastasia A ## 9 Kyle K ## 10 Ana A ## # ... with 11 more rows student_list %&gt;% group_by(first_letter) %&gt;% count() %&gt;% ungroup() %&gt;% mutate(prop = n / sum(n)) %&gt;% mutate(first_letter = fct_reorder(first_letter, prop)) %&gt;% ggplot(aes(x = first_letter)) + geom_bar(aes(weight = prop)) + coord_flip() + scale_y_continuous(labels = percent) + labs(x = &quot;&quot;, y = &quot;Percent of students with\\na name that starts with ...&quot;) What proportion of names start with “A” or “K” across the full dataset? You can create a dataframe that (1) pulls out the first letter of each name (just like we did for the last part of the question) and (2) tests whether that first letter is an “A” or a “K” (using a logical statement): a_or_k &lt;- babynames %&gt;% mutate(first_letter = str_sub(name, 1, 1), a_or_k = first_letter %in% c(&quot;A&quot;, &quot;K&quot;)) a_or_k %&gt;% select(name, first_letter, a_or_k) %&gt;% slice(1:5) ## # A tibble: 5 x 3 ## name first_letter a_or_k ## &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 Mary M FALSE ## 2 Anna A TRUE ## 3 Emma E FALSE ## 4 Elizabeth E FALSE ## 5 Minnie M FALSE Next, group by this logical column (a_or_k) and figure out the number of baby names for each group. Then, to get the proportion of the total, ungroup and mutate to divide by the total number across the data: a_or_k %&gt;% group_by(a_or_k) %&gt;% count() %&gt;% ungroup() %&gt;% mutate(prop = nn / sum(nn)) ## # A tibble: 2 x 3 ## a_or_k nn prop ## &lt;lgl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 FALSE 1563948 0.841 ## 2 TRUE 294741 0.159 How about for the years from 1980 to 1995? These proportions probably change over time, so let’s try to get the proportion for a time period relevant for this class. You can get this information very similarly as the last question, just filter to this range of years first: a_or_k_80s90s &lt;- babynames %&gt;% filter(1980 &lt;= year &amp; year &lt;= 1995) %&gt;% mutate(first_letter = str_sub(name, 1, 1), a_or_k = first_letter %in% c(&quot;A&quot;, &quot;K&quot;)) You can doublecheck that this dataframe has the right range of years: a_or_k_80s90s %&gt;% summarize(min_year = min(year), max_year = max(year)) ## # A tibble: 1 x 2 ## min_year max_year ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1980. 1995. Now do the same calculation as we did with the full dataset: a_or_k_80s90s %&gt;% group_by(a_or_k) %&gt;% count() %&gt;% ungroup() %&gt;% mutate(prop = nn / sum(nn)) ## # A tibble: 2 x 3 ## a_or_k nn prop ## &lt;lgl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 FALSE 298118 0.830 ## 2 TRUE 60893 0.170 Finally, how does the proportion change over the years in the dataframe? You can start from the a_or_k dataframe we created earlier. Group by year and the logical column a_or_k and then calculate the total number of baby names for each combination of year and a_or_k value. Then ungroup the data, group just by year, and get the proportion each year. Finally, filter to just the rows where a_or_k is true and plot how this changes over the years: a_or_k_year &lt;- a_or_k %&gt;% group_by(year, a_or_k) %&gt;% count() a_or_k_year ## # A tibble: 272 x 3 ## # Groups: year, a_or_k [272] ## year a_or_k nn ## &lt;dbl&gt; &lt;lgl&gt; &lt;int&gt; ## 1 1880. FALSE 1788 ## 2 1880. TRUE 212 ## 3 1881. FALSE 1724 ## 4 1881. TRUE 211 ## 5 1882. FALSE 1904 ## 6 1882. TRUE 223 ## 7 1883. FALSE 1859 ## 8 1883. TRUE 225 ## 9 1884. FALSE 2059 ## 10 1884. TRUE 238 ## # ... with 262 more rows a_or_k_year &lt;- a_or_k_year %&gt;% ungroup() %&gt;% group_by(year) %&gt;% mutate(prop = nn / sum(nn)) a_or_k_year ## # A tibble: 272 x 4 ## # Groups: year [136] ## year a_or_k nn prop ## &lt;dbl&gt; &lt;lgl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1880. FALSE 1788 0.894 ## 2 1880. TRUE 212 0.106 ## 3 1881. FALSE 1724 0.891 ## 4 1881. TRUE 211 0.109 ## 5 1882. FALSE 1904 0.895 ## 6 1882. TRUE 223 0.105 ## 7 1883. FALSE 1859 0.892 ## 8 1883. TRUE 225 0.108 ## 9 1884. FALSE 2059 0.896 ## 10 1884. TRUE 238 0.104 ## # ... with 262 more rows a_or_k_year %&gt;% filter(a_or_k == TRUE) %&gt;% ggplot(aes(x = year, y = prop)) + geom_line() + scale_y_continuous(name = &quot;Percent of baby&#39;s with names\\nthat start with &#39;A&#39; or &#39;K&#39;&quot;, labels = percent) + expand_limits(y = 0) "]
]
