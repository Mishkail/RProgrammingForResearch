[
["index.html", "R Programming for Research Online course book, ERHS 535", " R Programming for Research Colorado State University, ERHS 535 Brooke Anderson and Rachel Severson 2018-08-20 Online course book, ERHS 535 This is the online book for Colorado State University’s ERHS 535 R Programming for Research course. This book includes course information, course notes, links to download pdfs of lecture slides, in-course exercises, homework assignments, and vocabulary lists for quizzes for this course. ““Give someone a program, you frustrate them for a day; teach them how to program, you frustrate them for a lifetime.”—David Leinweber” This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License. "],
["course-information.html", "Course information 0.1 Course overview 0.2 Time and place 0.3 Detailed schedule 0.4 Grading 0.5 Course set-up 0.6 Coursebook", " Course information Download a pdf of the lecture slides covering this topic. 0.1 Course overview This document provides the course notes for Colorado State University’s ERHS 535 course for Fall 2018. The course offers in-depth instruction on data collection, data management, programming, and visualization, using data examples relevant to academic research. 0.2 Time and place This course meets in Room 120 of the Environmental Health Building on Mondays and Wednesdays, 10:00 am–12:00 pm. Exceptions to these meeting times are: There will be no meeting on Labor Day (Monday, Sept. 3). There are no course meetings the week of Thanksgiving (week of Nov. 19). I will be away from Fort Collins for two course dates (Aug. 27 and 29). I will videotape the lectures for these two class dates and post them online. I will offer a (voluntary) session on Aug. 31, 10:00-11:00 am, for anyone who would like to join to work on the in-course group exercises with classmates and with my feedback. 0.3 Detailed schedule Here is a more detailed view of the schedule for this course for Fall 2016: Dates Level Lecture content Graded items Aug. 20, 22 Preliminary R Preliminaries Aug. 27, 29 Basic Entering and cleaning data Sept. 5 Basic Exploring data Quiz (W) Sept. 10, 12 Basic Reporting data results Quiz (M), HW #1 (W) Sept. 17, 19 Basic Reproducible Research Quiz (M) Sept. 24, 26 Intermediate Entering and cleaning data Quiz (M), HW #2 (W) Oct. 1, 3 Intermediate Exploring data Quiz (M) Oct. 8, 10 Intermediate Reporting data results Quiz (M), HW #3 (W) Oct. 15, 17 Intermediate Reproducible Research Quiz (M), Group choices (M) Oct. 22, 24 Advanced Entering and cleaning data Quiz (M), Project proposal (M), HW #4 (W) Oct. 29, 31 Advanced Exploring data Nov. 5, 7 Advanced Reporting data results HW #5 (W) Nov. 12, 14 Advanced Mapping in R Nov. 26, 28 Advanced Package development 1 HW #6 (W) Dec. 3, 5 Advanced Package development 2 Project draft (M) Week of Dec. 10 Group presentations Final project (M) 0.4 Grading Course grades will be determined by the following five components: Assessment component Percent of grade Final group project 30 Weekly in-class quizzes, weeks 3-10 25 Homework 25 Attendance and class participation 10 Weekly in-course group exercises 10 0.4.1 Attendance and class participation Because so much of the learning for this class is through interactive work in class, it is critical that you come to class. Out of a possible 10 points for class attendance, you will get: 10 points if you attend all classes 8 points if you miss one class 6 points if you miss two classes 4 points if you miss three classes 2 points if you miss four classes 0 points if you miss five or more classes Exceptions: Attendance on the first day of class (Aug. 20) will not be counted. If you miss classes for “University-sanctioned”&quot; activities. These can include attending a conference, travel to collect data for your dissertation), For these absences, you must inform prior to the date that you will be absence. No points will be lost for attendance if you provide a signed letter from your research advisor by Dec. 11, 2017 (start of finals week), and you can make arrangements with me to make up any missed work. For more details, see CSU’s Academic Policies on Course Attendance. If you have to miss class for a serious medical issue (e.g., operation, sickness severe enough to require a doctor’s visit), the absence will be excused if you bring in a note from a doctor of other medical professional giving the date you missed and that it was for a serious medical issue. 0.4.2 Weekly in-course group exercises Part of each class will be spent doing in-course group exercises. Ten points of your final grade will be based on your participation in these exercises. As long as you are in class and participate in these exercises, you will get full credit for this component. If you miss a class, to get credit towards this component of your grade, you will need to turn in a one-page document describing what you learned from doing the in-course exercise on your own time. All in-class exercises are included in the online course book at the end of the chapter on the associated material. 0.4.3 In-class quizzes You will have eight total in-class quizzes. You will have one for each of the Week 3–10 class meetings. There will be at least 10 questions per quiz. You will get 1/3 point for each correct answer. If you do the math, you can get full credit for this if you get at least 75% of your answers right. You can not get more than the maximum of 25 points for this component– once you reach 25 points on quizzes, you will have achieved full credit for the quiz component of the course grade. All quiz questions will be multiple choice, matching, or some other form of “close-answered” question (i.e., no open-response-style questions). You can not make up a quiz for a class period you missed. You can still get full credit on your total possible quiz points if you miss a class, but it means you will have to work harder and get more questions right for days you are in class. Because grading format for these quizzes allows for you to miss some questions and still get the full quiz credit for the course, I will not ever re-consider the score you got on a previous quiz, give points back for a wrong answer on a poorly-worded question, etc. However, if a lot of people got a particular question wrong, I will be sure to cover it in the next class period. Also, especially if a question was poorly worded and caused confusion, I will work a similar question into a future quiz– in addition to the 10 guaranteed questions for that quiz– so every student will have the chance to get an extra 1/3 point of credit for the question. The “Vocabulary” appendix of our online book has the list of material for which you will be responsible for this quiz. Most of the functions and concepts will have been covered in class, but some may not. You are responsible for going through the list and, if there are things you don’t know or remember from class, learning them. To do this, you can use help functions in R, Google, StackOverflow, books on R, ask a friend, and any other resource you can find. The final version of the Vocabulary list you will be responsible will be posted by the Wednesday evening before each quiz. In general, using R frequently in your research or other coursework will help you to prepare and do well on these quizzes. 0.4.4 Homework There will be six homework assignments, starting a few weeks into the course and then due approximately every two weeks (see the detailed schedule in the online course book for exact due dates). The first homework (HW #1) should be done individually. For some other homeworks, you may be given the option to work in small groups of approximately three students. For later homeworks, a subset of the full set of questions will be selected for which I will do a detailed grading of the code itself, with substantial feedback on coding. All other questions in the homework will be graded for completeness and based on the final answer produced. For homeworks with a heavy coding component, I will provide solution code for all questions. Homework is due by the start of class on the due date. Your grade will be reduced by 10 points for each day it is late, and will receive no credit if it is late by over a week. 0.4.5 Final group project For the final project, you will work in small groups (3–4 people) on an R programming challenge. The final grade will be based on the resulting R software, as well as on a short group presentation and written report describing your work. You will be given a lot of in-class time during the last third of the semester to work with your group on this project, and you will also need to spend some time working outside of class to complete the project. More details on this project will be provided later in the semester. 0.5 Course set-up Please be sure you have the latest version of R and RStudio (Desktop version, Open Source edition) installed. Both are free for anyone to download. Also, be sure to sign up for a free GitHub account. Here are useful links for this set-up: R: https://cran.r-project.org RStudio: https://www.rstudio.com/products/rstudio/#Desktop Sign-up for a GitHub account: https://github.com 0.6 Coursebook This coursebook will serve as the only required textbook for this course. I am still in the process of editing and adding to this book, so content may change somewhat over the semester (particularly for the second half of the book, which is currently in a rawer draft than the beginning of the book). We typically cover about a chapter of the book each week of the course. This coursebook includes: Links to the slides presented in class for each topic In-course exercises, typically including links to the data used in the exercise An appendix with homework assignments A list of vocabulary and concepts that should be mastered for each quiz If you find any typos or bugs, or if you have any suggestions for how the book can be improved, feel free to post it on the book’s GitHub Issues page. This book was developed using Yihui Xie’s phenomenal bookdown framework. The book is built using code that combines R code, data, and text to create a book for which R code and examples can be re-executed every time the book is re-built, which helps identify bugs and broken code examples quickly. The online book is hosted using GitHub’s free GitHub Pages. All material for this book is available and can be explored at the book’s GitHub repository. 0.6.1 Other helpful books (not required) The best book to supplement the coursebook and lectures for this course is R for Data Science, by Garrett Grolemund and Hadley Wickham. The entire book is freely available online through the same format at the coursebook. You can also purchase a paper version of the book (published by O’Reilly) through Amazon, Barnes &amp; Noble, etc., for around $40. This book is an excellent and up-to-date reference by some of the best R programmers in the world. There are a number of other useful books available on general R programming, including: R for Dummies R Cookbook R Graphics Cookbook Roger Peng’s Leanpub books Various books on bookdown.org The R programming language is used extensively within certain fields, including statistics and bioinformatics. If you are using R for a specific type of analysis, you will be able to find many books with advice on using R for both general and specific statistical analysis, including many available in print or online through the CSU library. "],
["r-preliminaries.html", "Chapter 1 R Preliminaries 1.1 R and R Studio 1.2 The “package” system 1.3 Basic code conventions of R 1.4 R’s most basic object types 1.5 Using R functions 1.6 R scripts 1.7 In-course Exercise", " Chapter 1 R Preliminaries Download a pdf of the lecture slides covering this topic. 1.1 R and R Studio 1.1.1 What is R? R in an open-source programming language that evolved from the S language. The S language was developed at Bell Labs in the 1970s, which is the same place (and about the same time) that the C programming language was developed. R itself was developed in the 1990s–2000s at the University of Auckland. It is open-source software, freely and openly distributed under the GNU General Public License (GPL). The base version of R that you download when you install R on your computer includes the critical code for running R, but you can also install and run “packages” that people all over the world have developed to extend R. With new developments, R is becoming more and more useful for a variety of programming tasks. However, where it really shines is in working with data and doing statistical analysis. R is currently popular in a number of fields, including: Statistics Machine learning Data journalism / data analysis R has some of the same strengths (quick and easy to code, interfaces well with other languages, easy to work interactively) and weaknesses (slower than compiled languages) as Python. For data-related tasks, R and Python are fairly neck-and-neck (with Julia an up-and-coming option). However, R is still the first choice of statisticians in most fields, so I would argue that R has a an advantage if you want to have access to cutting-edge statistical methods. “The best thing about R is that it was developed by statisticians. The worst thing about R is that… it was developed by statisticians.” -Bo Cowgill, Google, at the Bay Area R Users Group 1.1.2 Open-source software “Life is too short to run proprietary software.” – Bdale Garbee R is open-source software. Many other popular statistical programming languages, conversely, are proprietary. It’s useful to know what it means for software to be “open-source”, both conceptually and in terms of how you will be able to use and add to R in your own work. R is free, and it’s tempting to think of open-source software just as “free software”. Things, however, are a little more subtle than that. It helps to consider some different meanings of the word “free”. “Free” can mean: Gratis: Free as in beer Libre: Free as in speech Figure 1.1: An overview of how software can be each type of free (beer and speech). For software programs developed using a compiled programming language, the final product that you open on your computer is run by machine-readable binary code. A developer can give you this code for free (as in beer) without sharing any of the original source code with you. This means you can’t dig in to figure out how the software works and how you can extend it. By contrast, open-source software (free as in speech) is software for which you have access to the human-readable code that was used as in input in creating the software binaries. With open-source code, you can figure out exactly how the program is coded. Open-source software software is the libre type of free (Figure 1.1). This means that, with software that is open-source, you can: Access all of the code that makes up the software Change the code as you’d like for your own applications Build on the code with your own extensions Share the software and its code, as well as your extensions, with others Popular open source licenses for R and R packages include the GPL and MIT licenses. “Making Linux GPL’d was definitely the best thing I ever did.” – Linus Torvalds In practice, this means that, once you are familiar with the software, you can dig deeply into the code to figure out exactly how it’s performing certain tasks. This can be useful for finding bugs and eliminating bugs, and also can help researchers figure out if there are any limitations in how the code works for their specific research. It also means that you can build your own software on top of existing R software and its extensions. I explain a bit more about R packages a bit later, but this open-source nature of R (and other languages, including Python) has created a large community of people worldwide who develop and share extensions to R. As a result, you can pull in packages that let you do all kinds of things in R, like visualizing Tweets, cleaning up accelerometer data, analyzing complex surveys, fitting maching learning models, and a wealth of other cool things. “Despite its name, open-source software is less vulnerable to hacking than the secret, black box systems like those being used in polling places now. That’s because anyone can see how open-source systems operate. Bugs can be spotted and remedied, deterring those who would attempt attacks. This makes them much more secure than closed-source models like Microsoft’s, which only Microsoft employees can get into to fix.” – Woolsey and Fox. To Protect Voting, Use Open-Source Software. New York Times. August 3, 2017. You can download the latest version of R from CRAN. Be sure to select the distribution for your type of computer system. R is updated occasionally; you should plan to re-install R at least once a year, to make sure you’re working with one of the newer versions. Check your current R version (one way is by running sessionInfo() at the R console) to make sure you’re not using an outdated version of R. Defaults should be fine for everything. “The R engine … is pretty well uniformly excellent code but you have to take my word for that. Actually, you don’t. The whole engine is open source so, if you wish, you can check every line of it. If people were out to push dodgy software, this is not the way they’d go about it.” - Bill Venables, R-help (January 2004) “Talk is cheap. Show me the code.” - Linus Torvalds 1.1.3 What is RStudio? To get the R software, you’ll download R from the R Project for Statistical Computing. This is enough for you to use R on your own computer. However, I would suggest one additional, free piece of software to improve your experience while working with R, RStudio. RStudio is an integrated development environment (IDE) for R. This basically means that it provides you an interface for running R and coding in R, with a lot of nice extras that will make your life easier. You download RStudio separately from R—you’ll want to download and install R itself first, and then you can download RStudio. You want the Desktop version with the free license. Defaults should be fine for everything. The company that develops this IDE is a fantastic contributer to the global R community. RStudio currently: RStudio (the company) is a leader in the R community. Currently, the company: Develops and freely provides the RStudio IDE Provides excellent resources for learning and using R (e.g., cheatsheets, free online books) Is producing some of the most-used R packages Employs some of the top people in R development Is a key member of The R Consortium (others include Microsoft, IBM, and Google) R has been advancing by leaps in bounds in terms of what it can do and the elegance with which it does it, in large part because of the enormous contributions of people involved with RStudio. 1.2 The “package” system 1.2.1 R packages “Any doubts about R’s big-league status should be put to rest, now that we have a Sudoku Puzzle Solver. Take that, SAS!” - David Brahm (announcing the sudoku package), R-packages (January 2006) Your original download of R is only a starting point. You can expand functionality of R with what are called packages, or extensions with new code and functionality that add to the basic “base R” environment. To me, this is a bit like the toy train set that my son was obsessed with for a while. You first buy a very basic set that looks something like Figure 1.2. Figure 1.2: The toy version of base R. To take full advantage of R, you’ll want to add on packages. In the case of the train set, at this point, a doting grandparent adds on extensively through birthday presents, so you end up with something that looks like Figure 1.3. Figure 1.3: The toy version of what your R set-up will look like once you find cool packages to use for your research. Each package is basically a bundle of extra R functions. You can get these “add-on” packages in a number of ways. The main source for installing packages for R remains the Comprehensive R Archive Network, or CRAN. However, GitHub is growing in popularity, especially for packages that are still in development. You can also create and share packages among your collaborators or co-workers, without ever posting them publicly. In the “Advanced” section of this course, you will learn how to write your own R package. 1.2.2 Installing from CRAN Figure 1.4: Celebrating CRAN’s 10,000th package. The most popular place from which to get packages is currently CRAN, which has over 10,000 R packages available (Figure 1.4). You can install packages from CRAN using R code, with the install.packages function. For example, telephone keypads include letters for each number (Figure 1.5), which allow companies to have “named” phone numbers that are easier for people to remember, like 1-800-GO-FEDEX and 1-800-FLOWERS. Figure 1.5: Telephone keypad with letters corresponding to each number. The phonenumber package is a cool little package that will convert between numbers and letters based on the telephone keypad. Since this package is on CRAN, you can install the package to your computer using the install.packages function: install.packages(&quot;phonenumber&quot;) This downloads the package from CRAN and saves it in a special location on your computer where R can load it when you’re ready to use it. Once you’ve installed a package to your computer this way, you don’t need to re-run this install.packages for the package ever again (unless the package maintainer posts an updated version). Just like R itself, packages often evolve and are updated by their maintainers. You should update your packages as new versions come out. Typically, you have to reinstall packages when you update your version of R, so this is a good chance to get the most up-to-date version of the packages you use. 1.2.3 Loading an installed package Once you have installed a package, it will be saved to your computer. However, you won’t be able to access its functions within an R session until you load it in that R session. Loading a package essentially makes all of the package’s functions available to you. You can load a package in an R session using the library function, with the package name inside the parentheses. library(&quot;phonenumber&quot;) Once a package is loaded, you can use all its exported (i.e., public) functions by calling them directly. For example, the phonenumber has a function called letterToNumber that converts a character string to a number. If you have not loaded the phonenumber package in your current R session and try to use this function, you will get an error. However, once you’ve loaded phonenumber using the library function, you can use this function in your R session: fedex_number &lt;- &quot;GoFedEx&quot; letterToNumber(fedex_number) ## [1] &quot;4633339&quot; R vectors can have several different classes. One common class is the character class, which is the class of the character string we’re using here (“GoFedEx”). You’ll always put character strings in quotation marks. Another key class is numeric (numbers). Later in the course, we’ll introduce other classes that vectors can have, including factors and dates. When you open RStudio, unless you reload the history of a previous R session (which I typically strongly do not recommend), you will start your work in a “fresh” R session. This means that, once you open RStudio, you will need to run the code to load any packages, define any objects, and read in any data that you will need for analysis in that session. If you are using a package in academic research, you should cite it, especially if it implements an algorithm or method that is not standard. You can use the citation function to get the information you need about how to cite a package: citation(&quot;phonenumber&quot;) ## ## To cite package &#39;phonenumber&#39; in publications use: ## ## Steve Myles (2015). phonenumber: Convert Letters to Numbers and ## Back as on a Telephone Keypad. R package version 0.2.2. ## https://CRAN.R-project.org/package=phonenumber ## ## A BibTeX entry for LaTeX users is ## ## @Manual{, ## title = {phonenumber: Convert Letters to Numbers and Back as on a Telephone Keypad}, ## author = {Steve Myles}, ## year = {2015}, ## note = {R package version 0.2.2}, ## url = {https://CRAN.R-project.org/package=phonenumber}, ## } We’ve talked here about loading packages using the library function to access their functions. However, this is not the only way to access the package’s functions. The syntax [package name]::[function name] (e.g., phonenumber::letterToNumber(fedex)) will allow you to use a function from a package you have installed on your computer, even if its package has not been loaded in the current R session. Typically, this syntax is not used much in data analysis scripts, in part because it makes the code much longer. However, you will occassionally see it used to distinguish between two functions from different packages that have the same name, as this format makes the desired function unambiguous. One example where this syntax often is needed is when both plyr and dplyr packages are loaded in an R session, since these share functions with the same name. Packages typically include some documentation to help users. These include: Package vignettes: Longer, tutorial-style documents that walk the user through the basics of how to use the package and often give some helpful example cases of the package in use. Function helpfiles: Files for each external function (i.e., the package maintainer wants it to be used by others) within the package, following an established structure. These include information about what inputs are required and optional for the function, what output will be created, and what options can be selected by the user. In many cases, these also include examples of using the function. To determine which vignettes are available for a package, you can use the vignette function, with the package’s name specified for the package option: vignette(package = &quot;phonenumber&quot;) From the output of this, you can call any of the package’s vignettes directly. For example, the previous call tells you that this package only has one vignette, and that vignette has the same name as the package (“phonenumber”). Once you know the name of the vignette you would like to open, you can also use vignette to open it: vignette(&quot;phonenumber&quot;) To access the helpfile for any function within a package you’ve loaded, you can use ? followed by the function’s name: ?letterToNumber 1.3 Basic code conventions of R 1.3.1 R objects In R, a variety of different types and structures of data can be saved in what’s called objects. For right now, you can just think of an R object as a discrete container of data in R. You can assign any R object you create its own name. Once you do this, you can use that object name to refer to the object. This means that you don’t need to re-create the object each time you need it—instead you can create it once and then just reference it by name each time you need it after that. For example, you can read in data from an external file as a dataframe object and assign it an object name. Then, when you need that data later, you won’t need to read it in again from the external file. You can think of object names as a bit like acronyms, in terms of being able to define something early in a document and then being able to use that short and simple name as a convenient way to refer to something complex every time you need to later in the document. 1.3.2 R’s MVP: The gets arrow The gets arrow, &lt;-, is R’s assignment operator. It takes whatever you’ve created on the right hand side of the &lt;- and saves that object with the object name you put on the left hand side of the &lt;-. The basic structure of a call with a gets arrow looks like this: ## Note: Generic code [name of object] &lt;- [thing I want to save] Sometimes, we’ll show “generic” code in a code block, that doesn’t actually work if you put it in R, but instead shows the generic structure of an R call. We’ll try to always include a comment with any generic code, so you’ll know not to try to run it in R. In R, objects are the way to save something to use again later in your code. If you do not assign something to an object with the gets arrow, R will just print it back out to you at the console. For example, if I just type &quot;GoFedEx&quot; at the R console, R will print that string back to me, but won’t save it anywhere for me to use later: &quot;GoFedEx&quot; ## [1] &quot;GoFedEx&quot; However, if I assign &quot;GoFedEx&quot; to an object using a gets arrow, I can print it out or use it later by typing (“referencing”) that object name: fedex_number &lt;- &quot;GoFedEx&quot; fedex_number ## [1] &quot;GoFedEx&quot; letterToNumber(fedex_number) ## [1] &quot;4633339&quot; You can assign the output of a function call directly to an object. For example, if you wanted to save the output of the letterToNumber call in the above code to its own object, you could do that with the call: fedex_actual_number &lt;- letterToNumber(fedex_number) fedex_actual_number ## [1] &quot;4633339&quot; If you give two objects the same name, the most recent definition will be used (i.e., objects can be overwritten by assigning new content to the same object name). For example: a &lt;- 1:10 b &lt;- LETTERS [1:3] a ## [1] 1 2 3 4 5 6 7 8 9 10 b ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; a &lt;- b a ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; If you would like to see all the R objects that are currently defined (i.e., have their own object names) in your R session, you can do that with the ls command: ls() ## [1] &quot;a&quot; &quot;b&quot; &quot;fedex_actual_number&quot; ## [4] &quot;fedex_number&quot; If you want to see the contents of an object, just print its name. For example, to see what we have stored in the fedex_number object, you can run: fedex_number ## [1] &quot;GoFedEx&quot; In R, at heart everything is an object, so this printing even works for things like functions. For example, to see the source code with which the letterToNumber function is defined, you can run (notice the lack of parentheses): letterToNumber ## function (value, qz = 1) ## { ## value &lt;- as.character(value) ## value &lt;- gsub(&quot;[^A-Za-z0-9]&quot;, &quot;-&quot;, value) ## value &lt;- toupper(value) ## valueSplit &lt;- strsplit(value, &quot;&quot;)[[1]] ## numString &lt;- as.character() ## mapphone &lt;- function(char) { ## if (qz == 0 &amp;&amp; (char == LETTERS[17] | char == LETTERS[26])) { ## &quot;0&quot; ## } ## else { ## ifelse(is.element(char, LETTERS[1:3]), &quot;2&quot;, ifelse(is.element(char, ## LETTERS[4:6]), &quot;3&quot;, ifelse(is.element(char, LETTERS[7:9]), ## &quot;4&quot;, ifelse(is.element(char, LETTERS[10:12]), ## &quot;5&quot;, ifelse(is.element(char, LETTERS[13:15]), ## &quot;6&quot;, ifelse(is.element(char, LETTERS[16:19]), ## &quot;7&quot;, ifelse(is.element(char, LETTERS[20:22]), ## &quot;8&quot;, ifelse(is.element(char, &quot;-&quot;) | suppressWarnings(!is.na(as.numeric(char))), ## char, &quot;9&quot;)))))))) ## } ## } ## numString &lt;- lapply(valueSplit, mapphone) ## return(paste0(numString, collapse = &quot;&quot;)) ## } ## &lt;bytecode: 0x7fa015d993f8&gt; ## &lt;environment: namespace:phonenumber&gt; 1.3.3 Assignment operator wars: &lt;- vs. = You can make assignments in R using either the gets arrow (&lt;-) or =. When you read other people’s code, you’ll see both. R gurus advise using &lt;- rather than = when coding in R, and as you move to doing more complex things, some subtle problems might crop up if you use =. I have heard from someone in the know that you can tell the age of a programmer by whether he or she uses the gets arrow or =, with = more common among the young and hip. For this course, however, I am asking you to code according to Hadley Wickham’s R style guide, which specifies using the gets arrow for assignment. While you will be coding with the gets arrow exclusively in this course, it will be helpful for you to know that the two assignment arrows do pretty much the same thing: one_to_ten &lt;- 1:10 one_to_ten ## [1] 1 2 3 4 5 6 7 8 9 10 one_to_ten = 1:10 one_to_ten ## [1] 1 2 3 4 5 6 7 8 9 10 While the gets arrow takes two key strokes instead of one (like the equals sign), you can somewhat get around this limitation by using RStudio’s keyboard shortcut for the gets arrow. This shortcut is Alt + - on Windows and Option + - on Macs. To see a full list of RStudio keyboard shortcuts, go to the “Help” tab in RStudio and select “Keyboard Shortcuts”. 1.3.4 Naming objects When you assign objects, you will need to choose names for them. This object name is what you will type later in your code to reference the object and use it in functions, figures, etc. For example, with the following code, I am assigning the character string “GoFedEx” to an object that I am naming fedex_number: fedex_number &lt;- &quot;GoFedEx&quot; There are only two fixed rules for naming objects in R: Use only letters, numbers, and underscores Don’t start with anything but a letter In addition to these fixed rules, there are also some guidelines for naming objects that you should adopt now, since they will make your life easier as you advance to writing more complex code in R. The following three guidelines for naming objects are from Hadley Wickham’s R style guide: Use lower case for variable names (fedex_number, not FedExNumber) Use an underscore as a separator (fedex_number, not fedex.number or fedexNumber) Avoid using names that are already defined in R (e.g., don’t name an object mean, because a function named mean already exists) “Don’t call your matrix ‘matrix’. Would you call your dog ‘dog’? Anyway, it might clash with the function ‘matrix’.” - Barry Rowlingson, R-help (October 2004) Another good practice is to name objects after nouns (e.g., fedex_number) and later, when you start writing functions, name those after verbs (e.g., call_fedex). You’ll want your object names to be short enough that they don’t take forever to type as you’re coding, but not so short that you can’t remember what they stand for. Sometimes, you’ll want to create an object that you won’t want to keep for very long. For example, you might want to create a small object to test some code, but you plan to not need the object again once you’ve done that. You may want to come up with some short, generic object names that you use for these kinds of objects, so that you’ll know that you can delete them without problems when you want to clean up your R session. There are all kinds of traditions for these placeholder variable names in computer science. foo and bar are two popular choices, as are, evidently, xyzzy, spam, ham, and norf. There are different placeholder names in different languages: for example, toto, truc, and azerty (French); and pippo, pluto, paperino (Disney character names; Italian). See the Wikipedia page on metasyntactic variables to find out more. 1.4 R’s most basic object types An R object stores some type of data that you want to use later in your R code, without fully recreating it. The content of R objects can vary from very simple (the &quot;GoFedEx&quot; string in the example code above) to very complex objects with lots of elements (for example, a machine learning model). There are a variety of different object types in R, shaped to fit different types of objects ranging from the simple to complex. In this section, we’ll start by describing two object types that you will use most often in basic data analysis, vectors (1-dimensional objects) and dataframes (2-dimensional objects). 1.4.1 Vectors To get an initial grasp of the vector object type in R, think of it as a 1-dimensional object, or a string of values. All values in a vector must be of the same class (i.e., all numbers, all characters, all dates). If you try to create a vector with elements from different classes (like “FedEx”, which is a character, and 3, a number), R will coerce all of the elements to the most generic class of any of the elements (i.e., “FedEx” and “3” will both become characters, since “3” can be changed to a character, but “FedEx” can’t be changed to a number). To create a vector from different elements, you’ll use the concatenation function, c to join them together, with commas between the elements. For example, to create a vector with the first five elements of the Fibonacci sequence, you can run: fibonacci &lt;- c(1, 1, 2, 3, 5) fibonacci ## [1] 1 1 2 3 5 Here is an example of creating a vector using elements with the character class instead of numbers (note the quotation marks used around each element for character strings): one_to_five &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;) one_to_five ## [1] &quot;one&quot; &quot;two&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; If you mix classes when you create the vector, R will coerce all the elements to most generic of the elements’ classes: mixed_classes &lt;- c(1, 3, &quot;five&quot;) mixed_classes ## [1] &quot;1&quot; &quot;3&quot; &quot;five&quot; A vector’s length is the number of elements in the vector. You can use the length function to determine a vector’s length: length(mixed_classes) ## [1] 3 Once you create an object, you will often want to reference the whole object in future code. However, there will be some times when you’ll want to reference just certain elements of the object (for example, the first three values). You can pull out certain values from a vector by using indexing with square brackets ([...]) to identify the locations of the elements you want to pull, with a numeric vector inside the brackets that lists the numbered positions of the elements you want to get: fibonacci[2] # Get the second value ## [1] 1 fibonacci[c(1, 5)] # Get first and fifth values ## [1] 1 5 fibonacci[1:3] # Get the first three values ## [1] 1 1 2 You can also use logic to pull out some values of a vector. For example, you might only want to pull out even values from the fibonacci vector. We’ll cover using logical statements to index vectors later in the book. One thing that people often find confusing when they start using R is knowing when to use and not use quotation marks. The general rule is that you use quotation marks when you want to refer to a character string literally, but no quotation marks when you want to refer to the value in a previously-defined object. For example, if you saved the string “Anderson” as the object my_name (my_name &lt;- “Anderson”), then in later code, if you type my_name (no quotation marks), you’ll get “Anderson”, while if you type out “my_name” (with quotation marks), you’ll get “my_name” (what you typed, literally). One thing that makes this rule confusing is that there are a few cases in R where you really should (by this rule) use quotation marks, but the function is coded to let you be lazy and get away without them. One example is the library function. In the code earlier in this section to load the “phonenumber” package, you want to literally load the package “phonenumber”, rather than load whatever character string is saved in the object named phonenumber. However, library is one of the functions where you can be lazy and skip the quotation marks, and it will still load “phonenumber” for you. Therefore, if you want, this function also works if you call library(phonenumber) (without the quotation marks) instead of how we actually called it (library(phonenumber)). 1.4.2 Dataframes A dataframe is a 2-dimensional object, and is made of one or more vectors of the same length stuck together side-by-side. It is the closest R has to an Excel spreadsheet-type structure. For example, here’s a dataframe with some basic information about the Beatles: ## # A tibble: 4 x 4 ## first_name last_name birth_year alive ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; ## 1 John Lennon 1940. FALSE ## 2 Paul McCartney 1942. TRUE ## 3 Ringo Starr 1940. TRUE ## 4 George Harrison 1943. FALSE Note that each row of this dataframe gives a different observation (in this case, our unit of observation is a Beatle). Each column gives a different type of information (first name, last name, birth year, and whether they’re still alive) for each of the observations (Beatles). Notice that the number of elements in each of the columns must be the same in this dataframe, but that the different columns can have different classes of data (e.g., character vectors for first_name and last_name, logical value of TRUE or FALSE for alive). You can create dataframes using the data_frame function from the tibble package. However, most often you will create a dataframe by reading in data from a file, using something like read_csv from the readr package. There are base R functions for both of these tasks (data.frame and read.csv, respectively), eliminating the need to load additional packages with a library call. However, the series of packages that make up what’s called the “tidyverse” have brought a huge improvement in the ease and speed of working with data in R. We will be teaching these tools in this course, and that’s why we’re going directly to data_frame and read_csv from the start, rather than base R equivalents. Later in the course, we’ll talk more about this “tidyverse” and what makes it so great. To create a dataframe, you can use the data_frame function from the tibble package. The general format for using data_frame is: ## Note: Generic code [name of object] &lt;- data_frame([1st column name] = [1st column content], [2nd column name] = [2nd column content]) with an equals sign between the column name and column content for each column, and commas between each of the columns. Here is an example of the code used to create the beatles object shown above: library(tibble) beatles &lt;- data_frame(first_name = c(&quot;John&quot;, &quot;Paul&quot;, &quot;Ringo&quot;, &quot;George&quot;), last_name = c(&quot;Lennon&quot;, &quot;McCartney&quot;, &quot;Starr&quot;, &quot;Harrison&quot;), birth_year = c(1940, 1942, 1940, 1943), alive = c(FALSE, TRUE, TRUE, FALSE)) You can also create a dataframe by sticking together vectors you already have saved as R objects. For example: fibonacci_seq &lt;- data_frame(num_in_seq = one_to_five, fibonacci_num = fibonacci) fibonacci_seq ## # A tibble: 5 x 2 ## num_in_seq fibonacci_num ## &lt;chr&gt; &lt;dbl&gt; ## 1 one 1. ## 2 two 1. ## 3 three 2. ## 4 four 3. ## 5 five 5. Note that this call requires that the one_to_five and fibonacci vectors are the same length, although they don’t have to be (and in this case aren’t) the same class of objects (one_to_five is a character class, fibonacci is numeric). You can put more than one function call in a single line of R code, as in this example (the c creates a vector, while the data.frame creates a dataframe, using the vectors created by the calls to c). When you use multiple functions within a single R call, R will evaluate starting from the inner-most parentheses out, much like the order of operations in a math equation with parentheses. You can use square-bracket indexing ([..., ...]) for dataframes, too, but now they’ll have two dimensions (rows, then columns). Put the rows you want before the comma, the columns after. If you want all of something (e.g., all rows in the dataframe), leave the designated spot blank. Here are two examples of using square-bracket indexing to pull a subset of the fibonacci_seq dataframe we created above: fibonacci_seq[1:2, 2] # First two rows, second column ## # A tibble: 2 x 1 ## fibonacci_num ## &lt;dbl&gt; ## 1 1. ## 2 1. fibonacci_seq[5, ] # Last row, all columns ## # A tibble: 1 x 2 ## num_in_seq fibonacci_num ## &lt;chr&gt; &lt;dbl&gt; ## 1 five 5. If you forget to put the comma in the indexing for a dataframe (e.g., fibonacci_seq[1:2]), you will index out the columns that fall at that position or positions. To avoid confusion, I suggest that you always use indexing with a comma when working with dataframes. So far, we’ve only shown how to create dataframes from scratch within an R session. Usually, however, you’ll create R dataframes instead by reading in data from an outside file using the read_csv from the readr package and related functions. For example, you might want to analyze data on all the guests that came on the Daily Show, circa Jon Stewart. If you have this data in a comma-separated (csv) file on your computer called “daily_show_guests.csv”, you can read it into your R session with the following code: ## Parsed with column specification: ## cols( ## YEAR = col_integer(), ## GoogleKnowlege_Occupation = col_character(), ## Show = col_character(), ## Group = col_character(), ## Raw_Guest_List = col_character() ## ) library(readr) daily_show &lt;- read.csv(&quot;daily_show_guests.csv&quot;, skip = 4) In this code, the read_csv function is reading in the data from “daily_show_guests”, while the gets arrow (&lt;-) assigns that data to the object daily_show, which you can then reference in later code to explore and plot the data. Once you’ve read in the data and saved the resulting dataframe as an object, you can use square-bracket indexing to look at the first two rows in the data: daily_show[1:2, ] ## # A tibble: 2 x 5 ## YEAR GoogleKnowlege_Occupation Show Group Raw_Guest_List ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1999 actor 1/11/99 Acting Michael J. Fox ## 2 1999 Comedian 1/12/99 Comedy Sandra Bernhard You can use the functions dim, nrow, and ncol to figure out the dimensions (number of rows and columns) of a dataframe: dim(daily_show) ## [1] 2693 5 nrow(daily_show) ## [1] 2693 ncol(daily_show) ## [1] 5 1.5 Using R functions 1.5.1 Function structure In general, functions in R take the following structure: ## Generic code function.name(parameter 1 = argument 1, parameter 2 = argument 2, parameter 3 = argument 3) The result of the function will be output to your R session, unless you choose to save the output in an object: ## Generic code new_object &lt;- function.name(parameter 1 = argument 1, parameter 2 = argument 2, parameter 3 = argument 3) Here are some example function calls, to give you examples of this structure: head(daily_show) ## # A tibble: 6 x 5 ## YEAR GoogleKnowlege_Occupation Show Group Raw_Guest_List ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1999 actor 1/11/99 Acting Michael J. Fox ## 2 1999 Comedian 1/12/99 Comedy Sandra Bernhard ## 3 1999 television actress 1/13/99 Acting Tracey Ullman ## 4 1999 film actress 1/14/99 Acting Gillian Anderson ## 5 1999 actor 1/18/99 Acting David Alan Grier ## 6 1999 actor 1/19/99 Acting William Baldwin head(daily_show, n = 3) ## # A tibble: 3 x 5 ## YEAR GoogleKnowlege_Occupation Show Group Raw_Guest_List ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1999 actor 1/11/99 Acting Michael J. Fox ## 2 1999 Comedian 1/12/99 Comedy Sandra Bernhard ## 3 1999 television actress 1/13/99 Acting Tracey Ullman ## Parsed with column specification: ## cols( ## `## Obtained from GitHub page of FiveThirtyEight under the` = col_character() ## ) ## Warning in rbind(names(probs), probs_f): number of columns of result is not ## a multiple of vector length (arg 1) ## Warning: 2694 parsing failures. ## row # A tibble: 5 x 5 col row col expected actual file expected &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; actual 1 4 &lt;NA&gt; 1 columns 5 columns &#39;data/daily_show_guests.csv&#39; file 2 5 &lt;NA&gt; 1 columns 5 columns &#39;data/daily_show_guests.csv&#39; row 3 6 &lt;NA&gt; 1 columns 5 columns &#39;data/daily_show_guests.csv&#39; col 4 7 &lt;NA&gt; 1 columns 5 columns &#39;data/daily_show_guests.csv&#39; expected 5 8 &lt;NA&gt; 1 columns 5 columns &#39;data/daily_show_guests.csv&#39; ## ... ................. ... .............................................................. ........ .............................................................. ...... .............................................................. .... .............................................................. ... .............................................................. ... .............................................................. ........ .............................................................. ## See problems(...) for more details. daily_show &lt;- read_csv(&quot;daily_show_guests.csv&quot;) Within the function call, parameters allow you to customize the function to run in a certain way (e.g., use a certain dataframe as an input, give output in a certain format). Some function parameters will have default arguments, which means that you don’t have to put a value for that parameter for the function to run, but you can if you want the function to do something other than the default. 1.5.2 Function help files You can find out more about a function, include what parameters it has and what the default values, if any, are by using ? before the function name in the R console. For example, to find out more about the read.csv command, run: ?read.csv From the “Usage” section of the help file, you can figure out that the only required parameter is file, the pathname of the file that you want to read in, since this is the only argument in the “Usage” example without an argument value: read.csv(file, header = TRUE, sep = &quot;,&quot;, quote = &quot;\\&quot;&quot;, dec = &quot;.&quot;, fill = TRUE, comment.char = &quot;&quot;, ...) You can also see from this “Usage” section that the default value of header is TRUE, the default value of sep is a comma, etc. The “Arguments” section explains each of the parameters, and possible arguments that each can take. For example, here is the explanation of the nrows parameter in the read.csv function: integer: the maximum number of rows to read in. Negative and other invalid values are ignored. From this, you can determine that you should put in a whole number, 1 or higher, and the function will only read in that many lines of the dataframe when you run read.csv. 1.5.3 Function parameters Each function parameter has a name (e.g., nrows, header, file). The safest way to call a function in R is to use the structure parameter name = argument value for every parameter, like this: head(x = daily_show, n = 3) However, you can also give argument values by position. For example, in the head function, the first parameter is x, the object you want to look at, and the second is n, the number of elements you want to include when you look at the object. If you know this, you can call head using the shorter call: head(daily_show, 3) If you use position alone, you will have problems if you don’t include arguments in exactly the right order. However, if you use parameter names to set each argument, it doesn’t matter what order you include arguments when calling a function: # These two calls return the exact same object head(x = daily_show, n = 3) head(n = 3, x = daily_show) Because code tends to be more robust to errors when you use parameter names to set arguments, we recommend against using position, rather than name, to give arguments when calling functions, at least while you’re learning R. It’s too easy to forget the exact order and get errors in your code. However, there is one exception– the first argument to a function is almost always required (i.e., there’s not a default value), and you very quickly learn what the first parameter of most functions are as soon as you start using the function regularly. Therefore, it’s fine to use position alone to specify the first argument in a function, but for now always use the parameter name to set any later arguments: head(daily_show, n = 3) Using the full parameter names for arguments can take a bit more time, since it requires more typing. However, RStudio helps you out with that by offering code completion. Once you start typing the first few letters of a parameter name within a function call, try pressing the tab key. All possible arguments that start with those letters should show up, and you can scroll through to pick the right one, or keep typing until the argument you want is atnthe top of the list of choices, and then press the tab key again. 1.6 R scripts This is a good point in learning R for you to start putting your work in R scripts, rather than entering commands at the console. An R script is a plain text file where you can save a series of R commands. You can save the script and open it up later to see (or re-do) what you did earlier, just like you could with something like a Word document when you’re writing a paper. To open a new R script in RStudio, go to the menu bar and select “File” -&gt; “New File” -&gt; “R Script”. Alternatively, you can use the keyboard shortcut Command-Shift-N. Figure 1.6 gives an example of an R script file opened in RStudio and points out some interesting elements. Figure 1.6: Example of an R script in RStudio. To save a script you’re working on, you can click on the “Save” button (which looks like a floppy disk) at the top of your R script window in RStudio or use the keyboard shortcut Command-S. You should save R scripts using a “.R” file extension. Within the R script, you’ll usually want to type your code so there’s one command per line. If your command runs long, you can write a single call over multiple lines. It’s unusual to put more than one command on a single line of a script file, but you can if you separate the commands with semicolons (;). These rules all correspond to how you can enter commands at the console. Running R code from a script file is very easy in RStudio. You can use either the “Run” button or Command-Return, and any code that is selected (i.e., that you’ve highlighted with your cursor) will run at the console. You can use this functionality to run a single line of code, multiple lines of code, or even just part of a specific line of code. If no code is highlighted, then R will instead run all the code on the line with the cursor and then move the cursor down to the next line in the script. You can also run all of the code in a script. To do this, use the “Source” button at the top of the script window. You can also run the entire script either from the console or from within another script by using the source() function, with the filename of the script you want to run as the argument. For example, to run all of the code in a file named “MyFile.R” that is saved in your current working directory, run: source(&quot;MyFile.R&quot;) You can add comments into an R script to let others know (and remind yourself) what you’re doing and why. To do this, use R’s comment character, #. Any line on a script line that starts with # will not be read by R. You can also take advantage of commenting to comment out certain parts of code that you don’t want to run at the moment. While it’s generally best to write your R code in a script and run it from there rather than entering it interactively at the R console, there are some exceptions. A main example is when you’re initially checking out a dataset, to make sure you’ve read it in correctly. It often makes more sense to run commands for this task, like str(), head(), tail(), and summary(), at the console. These are all examples of commands where you’re trying to look at something about your data right now, rather than code that builds toward your analysis, or helps you read in or clean up your data. 1.6.1 Commenting code Sometimes, you’ll want to include notes in your code. You can do this in all programming languages by using a comment character to start the line with your comment. In R, the comment character is the hash symbol, #. R will skip any line that starts with # in a script. For example, if you run the following code: # Don&#39;t print this. &quot;But print this&quot; ## [1] &quot;But print this&quot; R will only print the second, uncommented line. You can also use a comment in the middle of a line, to add a note on what you’re doing in that line of the code. R will skip any part of the code from the hash symbol on. For example: &quot;Print this&quot; ## But not this, it&#39;s a comment. ## [1] &quot;Print this&quot; There’s typically no reason to use code comments when running commands at the R console. However, it’s very important to get in the practice of including meaningful comments in R scripts. This helps you remember what you did when you revisit your code later. “You know you’re brilliant, but maybe you’d like to understand what you did 2 weeks from now.” – Linus Torvalds 1.7 In-course Exercise 1.7.1 About the dataset For today’s class, you’ll be using a dataset of all the guests on The Daily Show when Jon Stewart was the host. This data was originally collected by Nate Silver’s website, FiveThirtyEight and is available on FiveThirtyEight’s GitHub page under the Creative Commons Attribution 4.0 International License. I have copied this data into my GitHub repository for this class. The only change made to the original file was to add (commented) attribution information at the start of the file. First, check out a bit more about this data and its source: Check out the Creative Commons license. What are we allowed to do with this data? What restrictions are there on using the data? It’s often helpful to use prior knowledge to help check out or validate your dataset. One thing we might want to know about this data is if it covers the whole time that Jon Stewart hosted The Daily Show. Use Google to find out the dates he started and finished as host. Briefly browse around FiveThirtyEight’s GitHub data page. What are some other datasets available that you find interesting? For any dataset, you can scroll to the bottom of the page to get to the compiled README.md content, which gives the full titles and links to relevant datasets. You can also click on any dataset to get more information. Look at the GitHub page for this Daily Show data. How many columns will be in this dataset? What kind of information does the data include? What do the columns show? What do the rows show? In this exercise, you’re using data posted by FiveThirtyEight on GitHub. We’ll be using a lot of data that’s on GitHub this semester, and GitHub is being used behind-the-scenes for both this book and the course note slides. We’ll talk more about GitHub later, but you might find it interesting to explore a bit now. It’s a place where people can post, work on, and share code in a number of programming languages– it’s been referred to as “Facebook for Nerds”. You can search GitHub repositories and code specifically by programming language, so it can be a good way to find example R code from which to learn. If you have extra time: Check out the related article on FiveThirtyEight. What are some specific questions they used this data to answer for this article? Who is Nate Silver? 1.7.2 Manually creating vectors and a dataframe Start by manually creating some vectors and data frames with a small subset of this data. Use the concatenate function (c) to create a vector “from scratch” with the names of the five guests to appear on the show (these could be the first five guests, or you could also randomly pick five guests). Assign this vector to an object named five_guests. What class (numeric or character) do you think this vector will be? Will you need to use quotation marks for each element you add to the vector? Use square bracket indexing to print out the following subsets of this vector (you’ll have one R call per subset): (1) The first guest in the vector; (2) The third and fifth guests; (3) The second through fourth guests. Create a new vector called first_guest with just the first set, using the square bracket indexing you used in the previous step. In the same way, create a vector with the year of each of these guests’ appearances. Assign this vector to an object named appearance_year. What class (numeric or character) do you think this vector will be? Will you need to use quotation marks for each element you add to the vector? Use the class function to determine the classes (e.g., numeric, character) of each of the vectors you just created. Combine these two vectors to create a dataframe named guest_list. For the columns, use the same column names used in the original, raw data for the guest names and appearance year. Print out this dataframe at the R console to make sure it looks like you thought it would. Use square bracket indexing to print out the following subsets of this dataframe (you’ll have one R call per subset): (1) The appearance year of the first guest; (2) Names of the third through fifth guests; (3) Names of all guests; (4) Both names and appearance years of the first and third guests. The str function can be used to figure out the structure of a dataframe. Run this command on the guest_list dataframe you created. What information does this give you? Use the helpfile for str to help you figure this out (which you can access by running ?str). Do you see anything that surprises you? Use the ls function to list all the objects you currently have defined in your R session. Compare this list to the “Environment” pane in RStudio. Example R code: # I picked five random guests from throughout the dataset. The guests you pick will # likely be different. # Create a vector with the names of five guests five_guests &lt;- c(&quot;Miss Piggy&quot;, &quot;Stanley Tucci&quot;, &quot;Kermit the Frog&quot;, &quot;Hank Azaria&quot;, &quot;Al Gore&quot;) # Use square-bracket indexing to print out some subsets of the data five_guests[1] five_guests[c(3, 5)] five_guests[2:4] # Save just the first guest in a separate object first_guest &lt;- five_guests[1] first_guest # Create a vector with the year of the appearance of each guest appearance_year &lt;- c(1999, 2000, 2001, 2001, 2002) # Figure out the classes of the two vectors you just created class(five_guests) class(appearance_year) # Create the data frame, then print it out to make sure it looks like you thought # it would guest_list &lt;- data.frame(Raw_Guest_List = five_guests, YEAR = appearance_year) guest_list # Use square bracket indexing to print subsets of the data frame guest_list[1, 2] guest_list[3:5, 1] guest_list[ , 1] guest_list[c(1, 3), ] # Use `str` to check out the structure of the data frame you created str(guest_list) 1.7.3 Installing and using a package The stringr package includes a number of functions that make it easier to work with character strings in R. In particular, it includes functions to change the capitalization of words in character stings. Here, you’ll install and load this package and then use it to work with the five_guests vector we created in the last section. If you have not already installed the stringr package, install it from CRAN. Load the stringr package in your current R session, so you will be able to use its functions. Check if the package has a vignette. If so, check out out that vignette. See if you can use the str_to_lower function from the stringr package to convert all the names in your five_guests vector to lowercase. See if you can find a function in the stringr package that you can use to convert all the names in your five_guests vector to uppercase. (Hint: At the R console, try typing ?stringr:: and then the Tab key.) Example R code: # If you need to, install the package from CRAN install.packages(&quot;stringr&quot;) # Load the package into your current R session library(stringr) # Open the package&#39;s vignette vignette(&quot;stringr&quot;) # Convert the `five_guests` strings to lowercase str_to_lower(five_guests) # Convert the `five_guests` strings to uppercase str_to_upper(five_guests) 1.7.4 Getting the data onto your computer Next, we will work with the whole dataset. Download the data from GitHub onto your computer. Make a directory (folder) on your computer specifically for this course (I strongly recommend that you put it somewhere where the file path will not have any spaces in it–_for example, putting it in your home directory, under the name “r_course” would be great. Putting it in a directory called “R Course” would not.). Put the Daily Show data in your directory for this course. Take the following steps to get the data onto your computer If you do not yet have a directory (folder) just for this course, make one someplace straightforward like in your home directory. Do not use any spaces in the directory name. Download the file from GitHub. Right click on Raw and then choose “Download linked file”. Put the file into the directory you created for this course. Make this directory an R Project. Within RStudio, go to “File -&gt; New Project…”. Select to create a new project from an existing directory. Navigate to the directory you created for the course and select that. If the top right hand corner does not have the name you used for this directory in the top right, next choose to open this new project. Use the list.files command to make sure that the “daily_show_guests.csv” file is in your current working directory, now that you’re working within this RStudio Project (we’ll talk more about these Projects later in the semester). 1.7.5 Getting the data into R Now that you have the dataset in your working directory, you can read it into R. This dataset is in a csv (comma separated values) format. (We will talk more about different file formats next week.) You can read csv files into R using the read.csv function. Read the data into your R session If you do not already have it, install the readr package. Then load this package within your current R session using library. Use the read_csv function from the readr package to read the data into R and save it as the object daily_show. Use the help file for the read_csv function to figure out how this function works. To pull that up, type ?read_csv at the R console. Can you figure out why we’re using the skip option, and why it’s set to 4? Note that you need to put the file name in quotation marks. What would have happened if you’d used read_csv but hadn’t saved the result as the object daily_show? (For example, you’d run the code read_csv(&quot;daily_show_guests.csv&quot;) rather than daily_show &lt;- read_csv(&quot;daily_show_guests.csv&quot;).) Example R code: # Install (if needed) and load the `readr` package install.packages(&quot;readr&quot;) # You only need to do this if you # do not already have the `readr` # package. library(readr) # Read in dataframe from the csv file with Daily Show guests daily_show &lt;- read_csv(&quot;daily_show_guests.csv&quot;, skip = 4) If you have extra time: Say this was a really big dataset. You want to check out just the first 10 rows to make sure that you’ve got your code right before you take the time to pull in the whole dataset. Use the help file for read.csv to figure out how to only read in a few rows. Look through the help file for other options available for read.csv. Can you think of examples when some of these options would be useful? Look again at the version of this raw data on FiveThirtyEight’s GitHub page (rather than the course’s GitHub repository, where you downloaded the data for the course exercise). How are these two versions of the raw data different? How would you need to change your read.csv call if you changed to use the FiveThirtyEight version of the raw data? Example R code: # Read in only the first 10 rows of the dataset daily_show_first10 &lt;- read_csv(&quot;daily_show_guests.csv&quot;, skip = 4, n = 10) daily_show_first10 1.7.6 Checking out the data You now have the data available in your current R session as the daily_show object. You’ll want to check it out to make sure it read in correctly, and also to get a feel for the data. Throughout, you can use the help pages to figure out more about any of the functions being used (for example, ?dim). Take the following steps to check out the dataset Use the dim function to find out how many rows and columns this dataframe has. Based on what you found out about the data from the GitHub page, does it have the number of columns you expected? Based on what you know about the data (all the guests who came on The Daily Show with Jon Stewart), do you think it has about the right number of rows? Use indexing to look at the first two rows of the dataset. Based on this, what does each row “measure”? What information do you get for each “measurement”? As a reminder, indexing uses square brackets immediately after the object name. If the object has two dimensions, like a dataframe (rows and columns), you put the rows you want, then a comma, then the columns you want. If you want all rows (or columns), you leave that space blank. For example, if you wanted to get the first two rows and the first three columns, you’d use daily_show[1:2, 1:3]. If you wanted to get the first five rows and all the columns, you’d use daily_show[1:5, ]. Use the head function to look at the first few rows of the dataframe. Does it look like the rows go in order by date? What was the date of Jon Stewart’s first show? Does it look like this dataset covers that first show? Use the tail function to look at the last few rows of the dataframe. What is the last show date covered by the dataframe? Who was the last guest? Use the str function to get more details about the daily_show dataframe you read in. Example R code: # Use indexing to see a subset of the data daily_show[1:2, ] # Check the dimensions of the data dim(daily_show) head(daily_show) tail(daily_show) If you have extra time: Say you wanted to look at the first ten rows of the dataframe, rather than the first six. How could you use an option with head to do this? Example R code: # Look at the first few rows of the data head(daily_show, n = 10) 1.7.7 Using the data to answer questions Nate Silver was a guest on The Daily Show. Let’s use this data to figure out how many times he was a guest and when he was on the show. Find out more about Nate Silver on The Daily Show The subset function can be combined with logical statements to help you create a specific subset of data. For example, if you only wanted data from guest visits in 1999, you could run subset(daily_show, YEAR == 1999). Check out the helpfile for subset and use the function to create a new dataframe that only has the rows of daily_show when Nate Silve was a guest. Put it in the object nate_silver. Print out the full nate_silver dataframe by typing nate_silver. (You could just use this to answer both questions, but still try the next steps. They would be important with a bigger dataset.) To count the number of times Nate Silver was a guest, you’ll need to count the number of rows in the new dataset. You can either use the dim function or the nrow function to do this. What additional information does the dim function give you? To get the dates when Nate Silver was a guest, you can print out just the Show column of the dataframe. There are a few ways you can do this using indexing: nate_silver[ , 3] (since Show is the third column), nate_silver[ , &quot;Show&quot;], or nate_silver$Show. Try these. Example R code: # Create a subset of the data with just Nate Silver appearances nate_silver &lt;- subset(daily_show, Raw_Guest_List == &quot;Nate Silver&quot;) # Investigate this subset of the data nate_silver dim(nate_silver) nrow(nate_silver) nate_silver[ , 3] nate_silver[ , &quot;Show&quot;] If you have extra time: When you print out the Show column, why does it also print out something underneath about Levels? Hint: This has to do with the class that R has saved this column as. What class is it currently? What other classes might we want to consider converting it to as we continue working with the dataset? Check out the example code below to get some ideas. Was Nate Silver the only statistician to be a guest on the show? What were the occupations that were only represented by one guest visit? Since GoogleKnowlege_Occupation is a factor, you can use the table function to create a new vector with the number of times each value of GoogleKnowlege_Occupation shows up. You can put this information into a new vector and then pull out only the values that equal 1 (so, only had one guest). (Note that “Statistician” doesn’t show up– there was only one person who was a guest, but he had three visits.) Pick your favorite “one-off” example and find out who the guest was for that occupation. Example R code: class(nate_silver$Show) range(nate_silver$Show) nate_silver$Show &lt;- as.Date(nate_silver$Show, format = &quot;%m/%d/%y&quot;) range(nate_silver$Show) diff(range(nate_silver$Show)) # Time between Nate&#39;s first and last shows statisticians &lt;- subset(daily_show, GoogleKnowlege_Occupation == &quot;Statistician&quot;) statisticians num_visits &lt;- table(daily_show[ , 2]) head(num_visits) # Note: This is a vector rather than a dataframe names(num_visits[num_visits == 1]) subset(daily_show, GoogleKnowlege_Occupation == &quot;chess player&quot;) subset(daily_show, GoogleKnowlege_Occupation == &quot;mathematician&quot;) subset(daily_show, GoogleKnowlege_Occupation == &quot;orca trainer&quot;) subset(daily_show, GoogleKnowlege_Occupation == &quot;Puzzle Creator&quot;) subset(daily_show, GoogleKnowlege_Occupation == &quot;Scholar&quot;) 1.7.8 Writing your code as an R script While the R console is fine for initially exploring data, you should get in the habit of writing up R code in an R script for most of your data analysis projects in R. Open a new R script and save it to your current working directory (i.e., wherever you saved the data you downloaded for this exercise). Take some of the code that you wrote for this exercise (including the function to read the data into R). Put it in the R script. Do not put more than one function call per line (but it’s fine to have longer function calls span a few lines). Use the “Run” button to run a single line of this code. Check the console to see what happens when you do. Highlight a few lines of the code and use “Run” to run them. Try using the keyboard shortcut (Command-Return) to run the line of code your cursor is currently on. Try doing this with a function call that runs across several lines of the R script file– what do you see at the console? Try running the whole script using “Source”. Again, look at the console after you “source” the script. Close your R session (and save any changes to your R script). Do not save your R session history. Re-open R and see if you can re-open your R script and re-run it. Try using ls() to list the objects in your R session before and after you re-run your script. Does anything about the results surprise you? "],
["appendix-a-vocabulary.html", "A Appendix A: Vocabulary A.1 Quiz 1 A.2 Quiz 2 A.3 Quiz 3 A.4 Quiz 4 A.5 Quiz 5 A.6 Quiz 6 A.7 Quiz 7 A.8 Quiz 8", " A Appendix A: Vocabulary You will be responsible for knowing the following functions and vocabulary for the weekly quizzes. A.1 Quiz 1 c() data.frame() dim() ncol() nrow() head(), option n = read.csv, options head =, skip =, nrow = square bracket indexing: [...], [..., ...] getwd() setwd(), including setwd(&quot;~&quot;) list.files() ls() install.packages() library() “gets arrow”: &lt;- = length() package::function() notation vignette() basic classes of vectors: character and numeric class() str() summary() open source software “free as in beer” versus “free as in speech” CRAN GitHub R packages R working directory R session Working at the console versus using an R script tab completion How to download a csv file from GitHub RStudio vs. R Nate Silver FiveThirtyEight Grading policies for the course Course requirements / policies for in-class quizzes Style rules for naming R objects Difference between R and RStudio Vectors Dataframes Note: Pay attention in the course notes and exercise to where the code uses quotation marks and where it does not– this will help you in the quiz A.2 Quiz 2 source() Computer directory structure getwd() setwd(), including setwd(&quot;~&quot;), setwd(&quot;..&quot;), setwd(&quot;..\\..&quot;) NA relative pathnames absolute pathnames delimited files (csv, tsv) fixed width files R script file (How would you make a new one? What file extension would it have? Why is it important to use? How do you run code from a script file in RStudio?) What kinds of data can be read into R? How to read flat files of data that are online directly into R When you might want to save an R object as a .RData file and when (and why) you might not want to Reading in data from either a local or online flat file save(), option file = load() ls() The tidyverse functions in the read_* family (e.g., read_csv) paste(), option sep = paste0() readxl package and its read_excel() function haven package and its read_sas() function $ class() Main types of vector classes in R: character, numeric, factor, date, logical str() lubridate functions, include ymd, ymd_hm, mdy, wday, and mday dplyr package rename() select() slice() mutate() arrange(), including with desc() %&gt;%, advantages of piping filter() Common logical operators in R (==, !=, %in%, is.na(), &amp;, |) A.3 Quiz 3 data() (with and without the name of a dataset as an option) library() (with and without an argument in the parentheses) logical vectors, including running sum on a logical vector What the bang operator (!) does to a logical operator range() min() max() mean() median() table() cor(), both for two variables in a dataframe, and to get the correlation matrix for several variables in a dataframe summary(), as applied to: different classes of vectors (numeric, factor, logical) and dataframes What to do if you want to apply a summary statistic function to a vector with missing values (you do not need to know every option name for all the functions, just know that you would need to include an option like na.rm= or use=, and that you can use the help file for a function to figure out the option call for that function). The following about object-oriented programming: In R, it means that some functions, like summary(), will do different things depending on what type of object you call it on. summarize() Special functions to use with summarize(): n(), n_distinct(), first(), last() Using group_by() before using summarize() The three basic elements of a ggplot plot: data, aesthetics, and geoms aes function and common aesthetics, including color, shape, x, y, alpha, size, and fill Mapping an aesthetic to a column in the data versus setting it to a constant value Some common geoms: geom_histogram, geom_points, geom_lines, geom_boxplot() The difference between “statistical” geoms (e.g., geom_boxplot, geom_smooth) and “non-statistical” (e.g., geom_point, geom_line) Common additions to ggplot objects: ggtitle, labs, xlim, ylim, expand_limits A.4 Quiz 4 Guidelines for good graphics Data density / data-to-ink ratio Small multiples Edward Tufte Hadley Wickham Where to put the + in ggplot statements to avoid problems (ends of lines instead of starts of new lines) Can you save a ggplot object as an R object that you can reference later? If so, how would you add elements on to that object? How would you print it when you were ready to print the graph to your RStudio graphics window? geom_hline(), geom_vline() geom_text() facet_grid(), facet_wrap() grid.arrange() from the gridExtra package ggthemes package, including theme_few() and theme_tufte() Setting point color for geom_point() both as a constant (all points red) and as a way to show the level of a factor for each observation size, alpha, color Re-naming and re-ordering factors Note: If you read this and find and bring in an example of a “small multiples” graph (from a newspaper, a website, an academic paper), you can get one extra point on this quiz A.5 Quiz 5 Reproducible research, including what it is and advantages to aiming to make your research reproducible R style guidelines on variable names, &lt;- vs. =, line length, spacing, semicolons, commenting, indentation, and code grouping Markup languages (concept and examples) Basic conventions for Markdown (bold, italics, links, headers, lists) Literate programming What working directory R uses for code in an .Rmd document Basic syntax for RMarkdown chunks, including how to name them Options for RMarkdown chunks: echo, eval, messages, warnings, include, fig.width, fig.height, results Difference between global options and chunk options, and which takes precendence What inline code is and how to write it in RMarkdown How to set global options Why style is important in coding RPubs A.6 Quiz 6 Three characteristics of tidy data Five common problems with tidy data and how to resolve them (make sure you understand the examples shown, which you can find out more about in the Hadley Wickham paper I reference in the slides) group_by with mutate, slice, and arrange lag and lead with mutate separate and unite gather and spread The *_join family of functions (left_join, right_join, inner_join, full_join, anti_join, semi_join) A.7 Quiz 7 lists indexing from lists ([[ and $) exploring lists (class, names, str functions) Regression modeling with lm, glm Writing a formula with ~ syntax Using functions from broom to tidy model output (augment, tidy, glance) autoplot kable() from the knitr package How many objects a function can input. How many objects a function can output. if / else if / else structures inside functions Idea of error checking (e.g., with assertive package) A.8 Quiz 8 Regular expressions (the concept and which package you would use) nest and unnest (from purrr package) map family of functions basics of writing a function Mapping using ggplot2 framework with dataframes of geographical data (in the slides, “Point maps”) Choropleths, choroplethr map_data get_map ggmap "],
["appendix-b-homework.html", "B Appendix B: Homework B.1 Homework #1 B.2 Homework #2 B.3 Homework #3 B.4 Homework #4 B.5 Homework #5 B.6 Homework #6", " B Appendix B: Homework The following are six homework assignments for the course. B.1 Homework #1 Due date: Sept. 13 For your first homework assignment, you’ll be working through a few swirl lessons that are relevant to the material we’ve covered so far. Swirl is a platform that helps you learn R in R - you can complete the lessons right in your R console. Depending on your familiarity with R, you can either work through seven lessons of your choice in the R Programming: The basics of programming in R course (suggested lessons are listed further below) (Option #1), or you can work through seven lessons of your choice taken from any number of swirl’s available courses (Option #2) . For each lesson completed, please write a few sentences that cover: 1. A summary of the topic(s) covered in that lesson, and 2. The most interesting thing that you learned from that lesson. Turn in a hardcopy of this (with your first and last name at the top) during class on the due date. To begin, you’ll first need to install the swirl package: install.packages(&quot;swirl&quot;) Load the swirl package, then call the swirl() function to enter the interactive platform in RStudio. The console will take you through a few prompts: you’ll give swirl a name to call you, and take a look at some commands that are useful in the swirl environment. Those commands are listed further below. library(swirl) swirl() After calling swirl(), you may be prompted to clear your workspace variables by running rm=(list=ls()). Running this code will clear any variables you already have saved in your global environment. While swirl recommends that you do this, it’s not necessary. B.1.1 Option 1 If you’ve never run swirl() before, you will be prompted to install a course. Type 1 to install R Programming: The basics of programming in R. Now, every time you enter the swirl environment with swirl(), R Progamming should show up as a course option to select. You can enter R Programming to start lessons in that course by typing 1 again. For option 1 of this homework, you will need to work through seven of the 15 available lessons in the R Programming course. Here are some suggestions for particularly uesful lessons that you could choose (the lesson number is in parentheses): Basic Building Blocks (1) Vectors (4) Missing Values (5) Subsetting Vectors (6) Logic (8) Looking at Data (12) Dates and Times (14) Each lesson should take about 10-15 minutes, but some are much shorter. You can complete the lessons in any order you want, but you may find it easiest to start with the lowest-numbered lessons and work your way up, in the order we’ve listed the lessons here. You’ll be able to get started on some of these lessons after your first day in class (Basic Building Blocks, for example), but others cover topics that we’ll get to in weeks 2 and 3. Whether or not we’ve covered a swirl topic in class, you should be able to successfully work through the lesson. At the end of each lesson, you may be asked if you would like to receive credit for completing this course on Coursera.org. Type 2 for no. Again, you’ll need to compose and turn in a few sentences for each lesson. Make sure to include a summary of what each lesson was about, and the most interesting thing about that lesson. B.1.2 Option 2 If you’re already somewhat familiar with R, you might want to choose your seven lessons from other swirl courses instead of or in addition to those available in the R Programming course. To install a course other than R Programming, you can use the following steps: library(swirl) install_course(&quot;Course Name Here&quot;) swirl() Check out the list of available Swirl Courses to see which ones you would like to install and check out available lessons for. For example, to choose a lesson in the Getting and Cleaning Data course, you would run: library(swirl) install_course(&quot;Getting and Cleaning Data&quot;) swirl() After entering the Getting and Cleaning Data course, you could choose from any one of its four available lessons. In your written summary for each lesson (again, a few sentences that cover a summary of the lesson and the most interesting thing you learned), make sure to specify which course each lesson you completed was from. B.1.3 Special swirl commands In the swirl environment, knowing about the following commands will be helpful: Within each lesson, the prompt ... indicates that you should hit Enter to move on to the next section. skip(): skip the current question. play(): temporarily exit swirl. It can be useful during a swirl lesson to play around in the R console to try things out. nxt(): regain swirl’s attention after play()ing around in the console. main(): return to swirl’s main menu. bye(): exit swirl. Swirl will save your progress if you exit in the middle of a lesson. You can also hit the Esc. key to exit. (To re-enter swirl, run swirl(). In a new R session you will have to first load the swirl library: library(swirl).) B.1.3.1 For fun While they aren’t required for class, you should consider trying out some other swirl lessons later in the course. In R Programming, the Functions lesson, as well as lapply and sapply and vapply and tapply could be particularly useful. You can also look through the course directory to see what other courses and lessons are available. B.2 Homework #2 Due date: Sept. 27 For Homework 2, recreate the R Markdown document that you can download from here. Here are some initial instructions and tips: Your goal is to create an R Markdown document that you can compile to create a Word document that looks just like the example document we’ve linked above. You will turn in (by email) both the compiled Word document and the .Rmd original file. Add your name as “Author” and the due date of the assignment as “Date”. You should add these within the R Markdown document, rather than changing them in the final, compiled Word document. If you want to get started before you know how to use R Markdown, you can go ahead and write all of the necessary code to replicate the output and figures in the document in an R script. The code chunks here have been hidden with the option echo = FALSE, but you should include your code in your final document. Set the chunk options warning = FALSE and message = FALSE to prevent warnings and messages from being printed out. You will get some messages and warnings in the code from things like missing values and from loading packages, but you want to hide all of those messages in your final document. For things like templates, colors, level of transparency, and point size, you will receive full credit if you create figures that are visually similar to the ones shown in the example document. In other words, if the example document shows some transparency in points, you will get full credit if you also include some transparency in the points in your plot, but you do not have to include the exact same value of alpha. Pay close attention to the typeface used in text of the original document. If something is shown in boldface or “typewriter” fontface in the original, make sure you’ve written your Rmarkdown code to have the same type. In R, there are often many different ways to achieve something. As long as your code works, it’s fine if you haven’t coded it exactly like we have in our version. However, your output should look identical to ours (or, in the case of color, transparency, point size, and themes, visually similar). You will not lose points if you cannot recreate the table in the document (although you should try to!). The last section, under the heading “Extra challenge– not graded”, is not graded. However, if you’d like an extra challenge, you’re welcome to try it out and include it in your final submission! If you need them, here are some further tips: You will learn Rmarkdown in Week 5 of the course. However, if you want to get started on this exercise before you learn how to use Rmarkdown, you can start by working on the regular R code to read in the data and create the figures shown in the document. Functions from the tidyverse (especially from dplyr, readr, and ggplot packages) will make your life much easier for this exercise. You can now install and load the tidyverse package to load them all at once. To rename column names with “special” characters in them, wrap the whole old column name in backticks. For example, to change a column name that has a dollar sign in it, you would use something like “rename(new_col_name = `old_col_name$`)”. To change the size of a figure in a report, use the “fig.width” and “fig.height” chunk options. You will want to use scale_fill_brewer in several of the figures. Don’t forget that, within functions like scale_x_continuous, you can use the argument breaks to set where the axis has breaks, and then labels to set what will actually be shown at each break. The string “\\n” can be included in legends and labels to include a carriage return. Coordinates can be flipped in a graph with the coord_flip geom. So, if you can figure out a way to make a graph with the coordinates flipped, use that code and just add coord_flip at the end. B.3 Homework #3 Due date: Oct. 11 For Homework 3, recreate the R Markdown document that you can download from here. Here are some initial tips: Your goal is to create an R Markdown document that you can compile to create a Word document that looks just like the target document we’ve linked above. The only difference is that you will use echo = TRUE to show your code within the rendered Word document. All formating within the text should be similar or identical to the target document. You will turn in (by email) both the compiled Word document and the .Rmd original file. Add your name as “Author” and the due date of the assignment as “Date”. You should add these within the R Markdown document, rather than changing them in the final, compiled Word document. Set the chunk options warning = FALSE and message = FALSE to prevent warnings and messages from being printed out. You will get some messages and warnings in the code from things like missing values and from loading packages, but you want to hide all of those messages in your final document. For things like templates, colors, level of transparency, and point size, you will receive full credit if you create figures that are visually similar to the ones shown in the example document. In other words, if the example document shows some transparency in points, you will get full credit if you also include some transparency in the points in your plot, but you do not have to include the exact same value of alpha. In R, there are often many different ways to achieve something. As long as your code works, it’s fine if you haven’t coded it exactly like we have in our version. However, your output should look identical to ours (or, in the case of color, transparency, point size, and themes, visually similar). There is one formated table in the target document. Be sure that you render this as a formated table, not as raw R output. You will be graded on whether the size of each figure is similar to that in the example file. There is a tip in the “Further tips” section below about how to change figure size in the output. If you need them, here are some further tips: Functions from the tidyverse (especially from dplyr, readr, and ggplot packages) will make your life much easier for this exercise. To reference column names with “special” characters in them, like dollar signs or spaces, wrap the whole old column name in backticks. For example, to change a column name that has a dollar sign in it, you would use something like “rename(new_col_name = `old_col_name$`)”. To change the size of a figure in a report, use the “fig.width” and “fig.height” chunk options. B.4 Homework #4 Optional due date: Oct. 25 All instructions for this homework can be downloaded here. The example “fars_analysis.pdf” document you will try to recreate is here. You have the option to turn in parts of this homework (up through creating a clean dataset) by Oct. 28. If you do so, I will email you the code I used to clean the data, so you can check your own code and be sure you have a reasonable version of the clean data as you do the final parts of the assignment. B.5 Homework #5 Due date: Nov. 8 All instructions for this homework can be downloaded here. The example “fars_analysis.pdf” document you will try to recreate is here. You will submit this homework by posting a repo with your project directory on GitHub. We will work on setting that up during an in-course exercise. B.6 Homework #6 Due date: Nov. 29 Read the article Good Enough Practices in Scientific Computing by Wilson et al. (available here). In a half page, describe which of these “pretty good practices” your last homework incorporated. Also list one or two practices that you did not follow in your last homework but that would have made sense and how you could have followed them. Read the article Science Isn’t Broken on FiveThirtyEight. This article includes an interactive graphic. In a half page, give your opinion on whether this interactive graphic helps convey the main message of the article. Also, describe in general details how you might be able to create a graphic like this in R. Find an article in The R Journal that describes an R package that you could use in your own research or otherwise find interesting. Describe why the package was created and what you think it’s most interesting features are. In an R Markdown document, run one or two of the R examples included in the article. "]
]
